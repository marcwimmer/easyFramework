<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MathML.Rendering</name>
    </assembly>
    <members>
        <member name="T:MathML.Rendering.Area">
            interface describing basic geometric rendering area.
            TODO - import documentation from thesis.
        </member>
        <member name="F:MathML.Rendering.Area.areaGuid">
            string to identifiy an area in the MathMLElement node
        </member>
        <member name="M:MathML.Rendering.Area.#ctor">
            make sure that an instance of this base class is
            not created
        </member>
        <member name="M:MathML.Rendering.Area.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            render this area. 
        </member>
        <member name="M:MathML.Rendering.Area.Fit(MathML.Rendering.BoundingBox)">
            Fit this area to a given size. Some areas are not re-sizeable, 
            like glyph or string elements. Containers recursivly fit all of
            thier child nodes. Only 2 kinds of area return new types, 
            these are Filler areas, and Stretch glyphs.
        </member>
        <member name="M:MathML.Rendering.Area.Origin(MathML.Rendering.AreaIdentifier)">
            compute the horizontal component of the identified node's
            origin with respect to this node's origin, e.g. the identified
            node's reference point with respect to this node's refernce point.
            The following recursive relation holds:
            
            1: a node with no child nodes returns 0:
            a.Origin([]) = 0 
            
            2: a horizontal array returns the width of all previous nodes
            plus the origin of the identified node:
            HorizontalArray.Origin([k1,k2,k3,...kn] = sum(0.width -> k1.width) +
            k1.Origin([k2,k3,...kn])
            
            3: a node with child nodes that is not a horizontal array
            returns the identified node's origin:
            a.Origin([k1,k2,k3...kn]) = k1.Origin([k2,k3,...,kn])
        </member>
        <member name="M:MathML.Rendering.Area.GetIdentifier(MathML.Rendering.Area)">
            creates an identfier of the first occurrence of the argument
            during a depth-first visit of the area tree
            throws InvalidArea if the argument is not found
        </member>
        <member name="M:MathML.Rendering.Area.GetArea(MathML.Rendering.AreaIdentifier)">
            get an area with an identifier that is a relative path
            to this node.
        </member>
        <member name="M:MathML.Rendering.Area.GetPath(MathML.Rendering.Area,System.Collections.Stack)">
            create a path from this node to one of its' child nodes.
            a path from a node to itself is a zero lenght empty path.
            note, a path is a zero based offset to one of a node's
            child nodes.
            
            This method should return true if a path is found, false
            otherwise.
            
            The default implemtation just returns false. 
        </member>
        <member name="M:MathML.Rendering.Area.Clone">
            empty implementation of ICloneable interface. All implementors of this interface should
            perform ONLY A SHALLOW COPY. This method is comonly use by a comon base class in the 
            Fit operation.
        </member>
        <member name="M:MathML.Rendering.Area.GetEditRegion(System.Single,System.Single,System.Int32)">
            <summary>
            Get a editable (where a cursor can be placed) terminal or leaf area. 
            Terminal nodes should return themselves, and container areas should return 
            the first child node.
            </summary>
        </member>
        <member name="M:MathML.Rendering.Area.GetArea(MathML.MathMLElement)">
            get an area from a MathMLElement into which a area
            was previously set by SetArea
        </member>
        <member name="M:MathML.Rendering.Area.SetArea(MathML.MathMLElement,MathML.Rendering.Area)">
            set an area into a MathMLElement. The area can be later returned
            by GetArea.
            @return the area that is set into the element
        </member>
        <member name="P:MathML.Rendering.Area.Strength">
            The 'stretch strength', this is a measure of how capable of 
            stretching an area is. This is used for fitting in compund areas.
            The token area types are not re-sizable, so use this as a default,
            and return a zero re-size strength here in all directions. 
            
            The default Strength is all zeros, this means that it can not
            stretch in any direction.
        </member>
        <member name="T:MathML.Rendering.AreaFactory">
            A factory for all areas.
            Althoughg many area types can be constructed with thier
            own contstructor, many others are either compound, or are 
            shared, so for the sake of consistancy, all areas are created
            with this factory.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.String(MathML.Rendering.FormattingContext,System.String)">
            create an area that formats a string.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Box(MathML.Rendering.BoundingBox,MathML.Rendering.Area)">
            create a new box area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Color(System.Drawing.Color,MathML.Rendering.Area)">
            create a color area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Hide(MathML.Rendering.Area)">
            make a new hide area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Horizontal(MathML.Rendering.Area[])">
            create a horizontal area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.HorizontalCenter(MathML.Rendering.Area)">
            create a horizontal area with the given area 
            centered between two fillers. The HorizontalArea is created
            with a null element so that only the point inside the center area
            will return an element.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.HorizontalFiller">
            create a new horizontal filler area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.HorizontalLeft(MathML.Rendering.Area)">
            create a horizontal space area with the given
            area pushed to the left
        </member>
        <member name="M:MathML.Rendering.AreaFactory.HorizontalRight(MathML.Rendering.Area)">
            create a horizontal area with the given area pushed to
            the right
        </member>
        <member name="M:MathML.Rendering.AreaFactory.HorizontalSpace(System.Single)">
            create a horizontal space area with the given width
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Ink(MathML.Rendering.Area)">
            create an InkArea
        </member>
        <member name="M:MathML.Rendering.AreaFactory.HorizontalLine(System.Single)">
            create an area that will render a horizontal line. 
            this line will the the width of the bounding box that this
            area will be Fit in to.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.VerticalLine(System.Drawing.Color,System.Single)">
            create an area that will render a vertical line.
            this line will fill the height of the bounding box that
            this area will be Fit in to.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Shift(System.Single,MathML.Rendering.Area)">
            create a shift area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Vertical(MathML.Rendering.Area[],System.Int32)">
            create a vertical aray area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.VerticalBottom(MathML.Rendering.Area)">
            create an area that will pushed to the bottom of the
            space that it will be fit into
        </member>
        <member name="M:MathML.Rendering.AreaFactory.VerticalCenter(MathML.Rendering.Area)">
            create an area where the given area will be centered in
            the space that it will be fit into
        </member>
        <member name="M:MathML.Rendering.AreaFactory.VerticalFiller">
            create a vertical filler area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.VerticalSpace(System.Single,System.Single)">
            create a new vertical space area with the given height and depth
        </member>
        <member name="M:MathML.Rendering.AreaFactory.VerticalTop(MathML.Rendering.Area)">
            create an area where the given area will be pushed
            to the top of the space where the area will be fit
            in to
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Overlap(MathML.Rendering.Area[])">
            create an overlapped area
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Fraction(MathML.Rendering.FormattingContext,MathML.Rendering.Area,MathML.Rendering.Area,System.Int32)">
            Create a fraction area.
            This is an area that consists of 2 areas vertically separated by a line.
            this notion natuarally falls into the conecpt of a vertical array area, 
            an area, a line, and the second area.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Script(MathML.Rendering.FormattingContext,MathML.Rendering.Area,MathML.Rendering.Area,MathML.Length,MathML.Rendering.Area,MathML.Length)">
            format a script area. This is an area with a base, and
            optional super and subscript areas.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Radical(MathML.Rendering.FormattingContext,MathML.Rendering.Area,MathML.Rendering.Area)">
            format a radical
        </member>
        <member name="M:MathML.Rendering.AreaFactory.GetRadicalShift(MathML.Rendering.Area)">
            calculate vertical shift of the radical index.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.CalculateScriptShift(MathML.Rendering.FormattingContext,MathML.Rendering.BoundingBox,MathML.Rendering.BoundingBox,MathML.Length,MathML.Rendering.BoundingBox,MathML.Length,System.Single@,System.Single@)">
            calculate the default amout the script the baseline of the
            script rows. this ignores (for now anyway) the min shift values
            specified in the DOM
        </member>
        <member name="M:MathML.Rendering.AreaFactory.CalculateScriptShift(MathML.Rendering.FormattingContext,MathML.Rendering.BoundingBox,MathML.Rendering.BoundingBox,MathML.Rendering.BoundingBox,System.Single@,System.Single@)">
            calculate the default amout the script the baseline of the
            script rows. this ignores (for now anyway) the min shift values
            specified in the DOM.
        </member>
        <member name="M:MathML.Rendering.AreaFactory.Space(MathML.Rendering.BoundingBox)">
            <summary>
            create a space area that occupies the given size.
            </summary>
            <param name="size">the size to make a space area</param>
            <returns></returns>
        </member>
        <member name="T:MathML.Rendering.AreaIdentifier">
            The AreaIdentifer describes a relative path from  an area a 
            to either itself, or to one if its' descendent nodes. An 
            AreaIdentifer resembles the ChildSeq syntax in the XPointer 
            grammer. The AreaIdentifer path is a sequence of zero based
            offsets from one node to one if it's child nodes. If the path 
            is empty, it refers to the current area node. 
            Identifier paths are relative. A path from node a to node n is
            an path with lenght n at a. If b is the child node referneced 
            the first element of the path, the path at b now becomes lenght
            n - 1, the first element is removed, as that refered to the 
            offset at a to b.
            
            The GetArea method on Area should interpret a path as :
            a.GetArea([k1,k2,...kn]) = a.children[k1].GetArea([k2,k3,...kn]).
            
            An identifier from a node to itself is a  zero length, or 
            empty path. An identifier from a node to its' first child is a 
            path of length 1, with a single element with a value of 0, thus
            indicating the 0th child node.
            
            Take for example the following area tree:
            [area_a]
               |
            [area_b, area_c, area_d, area_e]
               |               |
            [area_f]        [area_g]
               |               |
               |            [area_h]
               |
            [area_i, area_j] 
            
            Where we have area_a as the root node, this has a list  of 
            children:[area_b,area_c,area_d,area_e], area_b has a child of 
            area_f, and so forth. In this case, we have the
            following following paths:
            
            a -> a = ""
            a -> b = "0"
            a -> c = "1"
            a -> d = "2"
            a -> e = "3"
            a -> f = a -> b -> f = "0,0"
            a -> g = a -> d -> g = "3,0"
            a -> i = a -> b -> f -> i = "0,0,0"
            a -> j = a -> b -> f -> j = "0,0,1"
            a -> h = a -> d -> g -> h = "2,0,0"
            
            The methods on AreaIdentifer allow it to be used as a forward 
            only enumerator, so that it can be easily pased recursivly 
            through an area tree.
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.#ctor">
            create a new empty identifer. An emtpy identifer
            is a path from a node to itself.
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.#ctor(System.Collections.Stack)">
            create a new identifier from the path information 
            stored in a stack. As a stack is created from bottom to
            top, we need to reverse the entries in it, as a identifer
            path is from top to bottom.
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.#ctor(System.Int32,MathML.Rendering.AreaIdentifier)">
            create a new identifier that is one larger than the given
            identifier, with the first element set to front.
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.#ctor(MathML.Rendering.AreaIdentifier)">
            create a new identifier that is next identifier relative
            to the given identifier. this takes the given identifier and
            makes a new identifier that has a path length one less than
            the given identier, and copies the all items except the first
            one. So if the given identifier is [k1,k2,k3,...,kn], the
            new identifier will be [k2,k3,...,kn].
            If the previous identifer is allready empty, an 
            InvalidArgument exception is thrown.
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.#ctor(System.Int32)">
            create a new identifier with a single path entry
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.#ctor(System.Int32[])">
            create a new identifier with a sequence of path entries, this 
            functions just like the ctor that accepts a stack.
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.MoveNext">
            move the identifier to the next position in its' path.
            if the identifier is at the end, MoveNext will have no
            affect. 
            returns true if there is a next postion, false otherwise
        </member>
        <member name="M:MathML.Rendering.AreaIdentifier.op_Increment(MathML.Rendering.AreaIdentifier)">
            shortcut for MoveNext method, as this object is moved
            next frequently
            note, even if this object it at its' end, this operator is 
            still OK. 
        </member>
        <member name="F:MathML.Rendering.AreaIdentifier.path">
            the path from a root node to one if its' decendents.
        </member>
        <member name="F:MathML.Rendering.AreaIdentifier.current">
            the index of the current item.
        </member>
        <member name="P:MathML.Rendering.AreaIdentifier.Current">
            gets the current value.
            throws InvalidOperationException if the current index
            is past the end of the array, or if the array is empty
        </member>
        <member name="P:MathML.Rendering.AreaIdentifier.End">
            Is this identifier at the end of its' path ?
            If an identifier is at the end, that means that it identifies
            the current node. An identifier with a zero lenght path is 
            allways at the end.
        </member>
        <member name="T:MathML.Rendering.AreaRegion">
            <summary>
            information describing the 'region' surrounding an area.
            This included the offset of an area to the starting postion, 
            and the inner most source mathml element
            </summary>
        </member>
        <member name="T:MathML.Rendering.BackgroundArea">
            <summary>
            set the background color of a branch of the area tree
            </summary>
        </member>
        <member name="T:MathML.Rendering.BinContainerArea">
            base class for all modifier areas, these are area that modify
            a single child area, such as Color, Ink, Box, etc...
        </member>
        <member name="T:MathML.Rendering.ContainerArea">
            an empty class that just signifies that a
            derived class is a container area, meaning that it contains
            a collection of child areas.
            
            note, this class may go in the future, as both containers
            derive from LinearContainer, and that derives from this class.
        </member>
        <member name="M:MathML.Rendering.ContainerArea.ReplaceChild(MathML.Rendering.Area,MathML.Rendering.Area)">
            Replaces the child node oldChild with newChild node.
            @param newChild The new node to put in the child list. 
            @param oldChild The node being replaced in the list. 
            @return The node replaced if found, null otherwise.
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.#ctor(MathML.Rendering.Area)">
            initialize the single child area
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            Render the Area. Most modifier area simply defer rendering
            to the child area.
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.Origin(MathML.Rendering.AreaIdentifier)">
            TODO write this up
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.Fit(MathML.Rendering.BoundingBox)">
            Default behavior is for a container area not to change any 
            properties of the bounding box, and simply fit the child
            to this box.
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.GetArea(MathML.Rendering.AreaIdentifier)">
            create an identifier for a descendant area.
            as a BinContainerArea can only have one direct child area, 
            the only valie identifiers are ones that are at the end of 
            thier path, indicating that it identifies this this node, 
            or an identifier with its' current element being zero, indicating
            that the current leg of its's path identifies the zero'th and
            only child node.
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.LeftSide(MathML.Rendering.AreaIdentifier)">
            TODO why do we do this
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.RightSide(MathML.Rendering.AreaIdentifier)">
            get the right side value.
            the identier is only valid if it is for the child
            node, or one of the child node's descendants. a 
            bin container can not have a right side value.
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.GetPath(MathML.Rendering.Area,System.Collections.Stack)">
            Find a path from an area a to either this node, 
            or its' child.
            returns true is a path is found, false otherwise
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.GetEditRegion(System.Single,System.Single,System.Int32)">
            <summary>
            Get the child area's terminal node
            </summary>
        </member>
        <member name="M:MathML.Rendering.BinContainerArea.ReplaceChild(MathML.Rendering.Area,MathML.Rendering.Area)">
            Replaces the child node oldChild with newChild node.
            @param newChild The new node to put in the child list. 
            @param oldChild The node being replaced in the list. 
            @return The node replaced if found, null otherwise.
        </member>
        <member name="F:MathML.Rendering.BinContainerArea.child">
            the single child area
        </member>
        <member name="F:MathML.Rendering.BinContainerArea.source">
            the source of this area from a fiting operation
        </member>
        <member name="P:MathML.Rendering.BinContainerArea.LeftEdge">
            return the child area's left edge
        </member>
        <member name="P:MathML.Rendering.BinContainerArea.RightEdge">
            return the child area's right edge
        </member>
        <member name="P:MathML.Rendering.BinContainerArea.Strength">
            just return the child's strength
        </member>
        <member name="P:MathML.Rendering.BinContainerArea.BoundingBox">
            just get the child areas bounding box
        </member>
        <!-- Badly formed XML comment ignored for member "T:MathML.Rendering.BoundingBox" -->
        <member name="M:MathML.Rendering.BoundingBox.New(System.Single,System.Single,System.Single)">
            <summary>
            create a new bounding box with the given parameters
            </summary>
        </member>
        <member name="M:MathML.Rendering.BoundingBox.New">
            <summary>
            create a new box with the default values
            unfourtunatly, with the current version of c#, you can not
            have default consturctors on structs, so we 'fake' one here
            so we can set the values that are appropriate for this context.
            </summary>
            <returns>a new bounding box</returns>
        </member>
        <member name="M:MathML.Rendering.BoundingBox.Append(MathML.Rendering.BoundingBox)">
            <summary>
            add the contents of the given bounding box to this bounding box
            </summary>
            <param name="box"></param>
        </member>
        <member name="M:MathML.Rendering.BoundingBox.Overlap(MathML.Rendering.BoundingBox)">
            <summary>
            set this box to the area that is the overlap of this box, 
            and the given box.
            </summary>
            <param name="box"></param>
        </member>
        <member name="M:MathML.Rendering.BoundingBox.Under(MathML.Rendering.BoundingBox)">
            <summary>
            set this size to a region made by placing this box
            under the given box, e.g add the vertical extent of the
            given box to the height this box.
            </summary>
            <param name="box"></param>
        </member>
        <member name="M:MathML.Rendering.BoundingBox.Over(MathML.Rendering.BoundingBox)">
            <summary>
            set this size to a region made by placing this box
            over the given box, e.g add the vertical extent of the
            given box to the depth this box.
            </summary>
            <param name="box"></param>
        </member>
        <member name="M:MathML.Rendering.BoundingBox.Contains(System.Single,System.Single,System.Single,System.Single)">
            determines if a bounding box contains the given point.
            @param x the x coordinate of the point
            @param y the y cooridnate of the point
            @return true if the box contains the point, false otherwise
        </member>
        <member name="F:MathML.Rendering.BoundingBox.Width">
            Horizontal distance from the reference point, and the left vertical 
            edge of the box
        </member>
        <member name="F:MathML.Rendering.BoundingBox.Height">
            distance above the baseline
        </member>
        <member name="F:MathML.Rendering.BoundingBox.Depth">
            distance below the baseline
        </member>
        <member name="P:MathML.Rendering.BoundingBox.VerticalExtent">
            get the total vertical distance of this box
        </member>
        <member name="P:MathML.Rendering.BoundingBox.HorizontalExtent">
            get the total horizontal distance of this box
            this just returns the Width, but is here to be consistant
            with VerticalExtent
        </member>
        <member name="P:MathML.Rendering.BoundingBox.Defined">
            true if this box has been set to non-default values
        </member>
        <member name="T:MathML.Rendering.BoxArea">
            TODO better documentation
        </member>
        <member name="M:MathML.Rendering.BoxArea.#ctor(MathML.Rendering.Area,MathML.Rendering.BoundingBox)">
            create a box area.
        </member>
        <member name="M:MathML.Rendering.BoxArea.Clone">
            clone the box area
        </member>
        <member name="P:MathML.Rendering.BoxArea.BoundingBox">
            get the bounding box.
            as a BoxArea is fit to a certain size, it returns
            that size here.
        </member>
        <member name="P:MathML.Rendering.BoxArea.Strength">
            box areas allways have 0 strength in all directions
            TODO figure out why
        </member>
        <member name="T:MathML.Rendering.ColorArea">
            the purpose of the color area is to change the rendering context 
            so that the default color for rendering is set to the specified
            color
        </member>
        <member name="M:MathML.Rendering.ColorArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            change the color of the rendering context, and call the child's
            render method recursivly
        </member>
        <member name="T:MathML.Rendering.InvalidIdentifier">
            the identifer is invalid for this node type
        </member>
        <member name="T:MathML.Rendering.InvalidOperation">
            the method is not supported in this node type
        </member>
        <member name="T:MathML.Rendering.FillerArea">
            a filler area is used to specify a space area that will fit the avalible
            space in the containing area. A filler area can be thought of as a spring
            that pushes the areas next to it to opposite directions. A filler area is
            meant to be a temporary area to be substituted by a space area in the
            Fit method.
        </member>
        <member name="T:MathML.Rendering.SimpleArea">
            Simple area is a terminal area, it will have no child areas
        </member>
        <member name="M:MathML.Rendering.SimpleArea.#ctor">
            make sure only derived class can create one of these
        </member>
        <member name="M:MathML.Rendering.SimpleArea.GetPath(MathML.Rendering.Area,System.Collections.Stack)">
            simple areas are terminal nodes, so if the given area
            matches this one, add a 0 indicating this is the end of the
            path and return true, otherwise return false indicating
            there is no path here.
        </member>
        <member name="M:MathML.Rendering.SimpleArea.GetArea(MathML.Rendering.AreaIdentifier)">
            simple areas are terminsl nodes, so make sure the identifer
            is empty at this point, and return this node, otherwise
            throw an invalid id exception
        </member>
        <member name="M:MathML.Rendering.SimpleArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            TODO, figure out why we do nothing here
        </member>
        <member name="M:MathML.Rendering.SimpleArea.Origin(MathML.Rendering.AreaIdentifier)">
            if the id id empty (at a terminal node), return 0, 
            otherwise throw an invalid id exception
            TODO figure out why we do this
        </member>
        <member name="M:MathML.Rendering.SimpleArea.LeftSide(MathML.Rendering.AreaIdentifier)">
            not supported on simple nodes
            TODO find out why
        </member>
        <member name="M:MathML.Rendering.SimpleArea.RightSide(MathML.Rendering.AreaIdentifier)">
            not supported on simple nodes
            TODO find out why
        </member>
        <member name="M:MathML.Rendering.SimpleArea.Clone">
            cloning a simple area makes no sense as cloning occurs only
            when fitting an area, and simple areas fit into themselves.
        </member>
        <member name="P:MathML.Rendering.SimpleArea.Strength">
            simple areas have zero strength in all directions
            TODO find out why
        </member>
        <member name="T:MathML.Rendering.FontFactory">
            <summary>
            Summary description for FontFactory.
            </summary>
        </member>
        <member name="F:MathML.Rendering.FontFactory.fonts">
            keep track of all the fonts that this class
            created. 
            
            This is a list of weak references, in that the font is freed when
            all references except this one are gone. Font or glyph areas hold
            strong references to fonts.
        </member>
        <member name="M:MathML.Rendering.FontFactory.GetFont(MathML.Rendering.FormattingContext)">
            create a font based only on the MathVariant and MathSize 
            fields of the FormattingContext
            Currently, this only a shortcut to GetFont(context, "", ""), but
            internally may be optimized in the future.
        </member>
        <member name="M:MathML.Rendering.FontFactory.GetFont(MathML.Rendering.FormattingContext,System.String,System.String)">
            get a font based on the font type given in the variant, 
            and the size given in height. If the size can not be 
            evaluated to a valid size, the default font size is used.
            the fontName override anything in the context if it is given.
        </member>
        <member name="M:MathML.Rendering.FontFactory.FindFont(System.Int32,System.Boolean,System.Int32,System.String)">
            try to find a font in the list that matches the contents
            of the formating context
        </member>
        <member name="P:MathML.Rendering.FontFactory.DefaultFontWeight">
            the default font weight, may change this to look up from
            some external source in the future.
        </member>
        <member name="T:MathML.Rendering.FontHandle">
            A way to store and locate native font resources.
            This class holds onto a native font resource, and the
            font attributes with which the native font was created.
            This is created by the RenderingDevice, and is held 
            currently by the glyph and font areas.
            When this class is disposed of, it will free the native 
            font resource
            
            The RenderingDevice will maintain a list of weak references
            to all fonts that it creates. When a request for a new font
            is made, the RenderingDevice will look through this list list
            for a matching font. If one is found, than a reference to the
            found font is returned.
            
            As the RenderingDevice contains only weak references to fonts, 
            the standard garbage collector will take care of freeing them
            when there are no more strong references.
        </member>
        <member name="M:MathML.Rendering.FontHandle.#ctor(System.IntPtr,System.Int32,System.Boolean,System.Int32,System.String)">
            create a math font.
        </member>
        <member name="F:MathML.Rendering.FontHandle.Handle">
            A reference to a native font resource.
        </member>
        <member name="F:MathML.Rendering.FontHandle.Height">
            the height in pixels that the native font was created with
        </member>
        <member name="F:MathML.Rendering.FontHandle.Italic">
            the italic state the native font was created with
        </member>
        <member name="F:MathML.Rendering.FontHandle.Weight">
            the weight the native font resource was created with
        </member>
        <member name="F:MathML.Rendering.FontHandle.Name">
            the name that the native font resource was created with.
        </member>
        <member name="M:MathML.Rendering.FontHandle.Equals(System.Int32,System.Boolean,System.Int32,System.String)">
            compare a set of font attributes to this font resouce.
        </member>
        <member name="M:MathML.Rendering.FontHandle.Finalize">
            free the native font resource
        </member>
        <member name="T:MathML.Rendering.GlyphMapper.FontInstance">
            a collection of glyphs that belong to a realized 
            font instance. As fonts can be created at any size, 
            this is an instnace of a font created at a particluar
            size. It caches a set of glyph areas that were created 
            with this font instance, and stores a set of glyph 
            sizes that are used to map a stretchy glyph.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.FontInstance.FontHandle">
            the native font handle that is the native font
            for this instance.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.FontInstance.GetCachedArea(System.Char)">
            locate an area that was previously cached in this 
            font instance
        </member>
        <member name="M:MathML.Rendering.FormattingContext.#ctor">
            <summary>
            default contstuctor
            </summary>
        </member>
        <member name="M:MathML.Rendering.FormattingContext.#ctor(System.Int32)">
            <summary>
            default contstuctor
            </summary>
        </member>
        <member name="M:MathML.Rendering.FormattingContext.#ctor(MathML.Rendering.FormattingContext)">
            <summary>
            make a new copy of an existing context
            </summary>
        </member>
        <member name="M:MathML.Rendering.FormattingContext.Evaluate(MathML.Length)">
            <summary>
            evaluate a length using the current font size (in pixels)
            as the default size
            </summary>
        </member>
        <member name="M:MathML.Rendering.FormattingContext.Evaluate(MathML.Length,System.Single)">
            <summary>
            evaluate a length to a true size in pixels. 
            this calculation is affected by the current font, and 
            by any previous (parent) style node. In gtkmathview, this 
            method was part of the graphic device, but I think that it
            makes more sense as part of the formatting context. This
            calculation is heavily dependent on the current state of
            formatting, and the formatting context manages that 
            state, so lenght evaluation should go here.
            </summary>
            <param name="length">a Math Length if the length is not valid, 
            the default valud is returned</param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.actualSize">
            <summary>
            the actual font size. this value is not to be used for creating fonts, 
            instead, use the Size value. This value is the true value of the font, 
            not taking into acount the min and max font sizes.
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.MathVariant">
            <summary>
            the MathVariant from a presentation token node
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.Color">
            <summary>
            color used for drawing
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.BackgroundColor">
            <summary>
            background color used for drawing
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.cacheArea">
            <summary>
            should the current area be cached?
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.Parens">
            <summary>
            currently used for content areas. If true, an apply element should use parens, as
            it is inside a function or some other item that does not need parens.
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.minSize">
            <summary>
            minimum font size that the script can be reduced to. This 
            defauts to the value of a 6 point font.
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.DisplayStyle">
            <summary>
            true if formulas must be formated in display mode
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.SizeMultiplier">
            <summary>
            amount by which the font size is multiplied when the script level
            is incresed or decreased by one
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.Stretch">
            <summary>
            the extent at which the node is being asked to stretch to
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.size">
            <summary>
            the font size
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.scriptLevel">
            <summary>
            the script level
            </summary>
        </member>
        <member name="F:MathML.Rendering.FormattingContext.veryVeryThin">
            <summary>
            scale factors for calculating thickneseses
            </summary>
        </member>
        <member name="P:MathML.Rendering.FormattingContext.Size">
            <summary>
            The current font size, this is the current emHeight of the font to used
            for creating areas when a node is formatted.
            </summary>
        </member>
        <member name="P:MathML.Rendering.FormattingContext.ScriptLevel">
            <summary>
            number of nested scripts
            </summary>
        </member>
        <member name="T:MathML.Rendering.GlyphArea">
            represents a single symbol on the screen. A glyph is
            different from a standard string, in that each glyph 
            contains a specific font. A standard glyph area is fixed
            and read only, it will not re-size to a Fit call.
            a glyph node is a terminal node, and is imutable. 
            as this node is imutable, we can pre-calculate the
            size, and cache it, as it is very expensive to calculate
            the glyph metrics.
            
            10-26-2003 
            Major optimization, calculate glyph metrics only once in ctor, 
        </member>
        <member name="F:MathML.Rendering.GlyphArea.index">
            the character index or value.
        </member>
        <member name="F:MathML.Rendering.GlyphArea.font">
            a reference to a font that is used by the graphic device
        </member>
        <member name="F:MathML.Rendering.GlyphArea.box">
            keep track of the size so we do not re-calculate them
        </member>
        <member name="M:MathML.Rendering.GlyphArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            render this area. 
        </member>
        <member name="M:MathML.Rendering.GlyphArea.GetArea(MathML.Rendering.AreaIdentifier)">
            get an area with an identifier that is a relative path
            to this node. This is a terminal node, so the identifier better 
            be at its' end.
        </member>
        <member name="M:MathML.Rendering.GlyphArea.Clone">
            glyph areas are read only terminal nodes, so just return this object
        </member>
        <member name="P:MathML.Rendering.GlyphArea.BoundingBox">
            get the bounding box, this was set in the ctor
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.GlyphAttributes.FudgeNone">
            fudge the reported glyph metrics so compound stretchy glyphs
            fit together nicely.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.GlyphAttributes.Box">
            standard set of attributes (metrics) for a glyph
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.GlyphAttributes.#ctor(System.IntPtr,System.Int16,System.Int32)">
             set the attributes, but do not actually create a glyph 
             area.
             @param fontHandle a handle to a native font resource
             @param charIndex the index in the font of the desired glyph
             @param stretchyType if this glyph is a repeated section in a
            		  stretchy glyph, shrink the reported metrics by one, so
            		  we get a nice overlap.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.GlyphAttributes.glyphArea">
            a weak refernece to a realized glyph area. This allows
            realized glyph areas to be shared, and allows the garbage
            collector to properly manage glyph area lifetimes.
            
            this is set by the container of this class.
        </member>
        <member name="T:MathML.Rendering.GlyphFactory">
            the source of glyphs.
            a glyph can be identified by a character index, and a font, 
            these are used to store each glyph in a hash table.
            
            glyphs are shared (using the flyweight patern), and therefore
            are read only.
            
            Most areas are created by the area factory, but glyphs are a 
            very speciallized area, and therefore all the logic to manage
            them has been islolated into this class.
        </member>
        <member name="F:MathML.Rendering.GlyphFactory.maps">
            a collection of glyph maps. each one is loaded from a config
            file nammed font-configuration-?????.xml. All files matching 
            this nameing convention in the specified directory are enumerated, 
            and a glyph map is loaded for each one.
        </member>
        <member name="M:MathML.Rendering.GlyphFactory.GetGlyph(System.Int32,System.Char)">
            create a new glyph area.
        </member>
        <member name="M:MathML.Rendering.GlyphFactory.GetStretchyGlyph(System.Int32,System.Char,MathML.Rendering.BoundingBox,System.Single@)">
            find or calculate an area that will fill the requested cell 
            height. The returned area may be either a single glyph, or a
            compound set of glyphs.
            
            @param pointSize the evaluated font size
            @param desiredSize the desired stretch size (for either vertical or 
            horizontal stretchy glyphs.
            @param c the character to find a glyph for.
            @param lineThickness a value that get populated with the thickness of the 
            repated or stretched sections.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.GlyphMap.GetGlyph(System.Int32,System.Char)">
            create a new glyph area.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.GlyphMap.GetStretchyGlyph(System.Int32,System.Char,MathML.Rendering.BoundingBox,System.Single@)">
            find or calculate an area that will fill the requested cell 
            height. The returned area may be either a single glyph, or a
            compound set of glyphs.
            
            @param pointSize the evaluated font size
            @param desiredSize the desired stretch size (for either vertical or 
            horizontal stretchy glyphs.
            @param c the character to find a glyph for.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.GlyphMap.GetSimpleIndex(System.Char)">
            locate a index for a simple glyph item.
            return -1 if none exists.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.GlyphMap.GetFontIndex(System.Int32)">
            find an index to a font that mathces the given font cell height, 
            if no font is availible, one is created with this height.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.GlyphMap.CreateFont(System.Int32)">
            create a font with the given font size. return the index of the new
            font, or -1 if we failed to create the font
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.GlyphMap.LoadXmlNode(System.Xml.XmlNode)">
            load one of the root xml nodes.
        </member>
        <member name="M:MathML.Rendering.HideArea.#ctor(MathML.Rendering.Area)">
            make a new hide area, initialize the 
            base class with the given child node
        </member>
        <member name="M:MathML.Rendering.HideArea.Clone">
            perform a shallow copy, as there are no
            attributes of this type
        </member>
        <member name="M:MathML.Rendering.HideArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            this is a hide area, so no rendering is done
        </member>
        <member name="T:MathML.Rendering.LinearContainer">
            provide base functionality to all container types
            (Horizontal and Vertical)
        </member>
        <member name="F:MathML.Rendering.LinearContainer.source">
            When this area is fited, this is the source area
        </member>
        <member name="M:MathML.Rendering.LinearContainer.#ctor(MathML.Rendering.Area[],MathML.Rendering.Area)">
            initialize the content.
        </member>
        <member name="M:MathML.Rendering.LinearContainer.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            render each child area with an un-updated rendering 
            context. Most containers need to update the rendering
            context to reflect a different positions for each 
            child area
        </member>
        <member name="M:MathML.Rendering.LinearContainer.GetPath(MathML.Rendering.Area,System.Collections.Stack)">
            find a path from this node to a child node  if area is this node, 
            append a 0 to the path indicating this is node that there is a 
            path to, otherwise iterate through each child node, adding the 
            index of the node the path, and see if there is a path to that node, 
            if no path is found, that index is poped from the stack, and the
            next node is tried. If there is no path to any node, false is
            returned
        </member>
        <member name="M:MathML.Rendering.LinearContainer.GetArea(MathML.Rendering.AreaIdentifier)">
            get a child area that has a path to this node
            if the identifier is at its's last item, this final step
            in the path, so return this node, otherwise, if the current step
            is valid (less than the size of the child node list, the child
            area at the current position will get the path moved to the next 
            position. If the id is not at it's end, and the current item is 
            out of range, an invalid id exception is thrown.
        </member>
        <member name="M:MathML.Rendering.LinearContainer.Origin(MathML.Rendering.AreaIdentifier)">
            if the id is at it's end (identifies this node), return 0, otherwise
            return the child node that it identifies' origin
        </member>
        <member name="M:MathML.Rendering.LinearContainer.LeftSide(MathML.Rendering.AreaIdentifier)">
            if the id is for this node, return 0. otherwise if the id is for
            a child node, return that node's left side.
        </member>
        <member name="M:MathML.Rendering.LinearContainer.RightSide(MathML.Rendering.AreaIdentifier)">
            if the id is for this node, return 0. otherwise if the id is for
            a child node, return that node's left side.
        </member>
        <member name="M:MathML.Rendering.LinearContainer.ReplaceChild(MathML.Rendering.Area,MathML.Rendering.Area)">
            Replaces the child node oldChild with newChild node.
            @param newChild The new node to put in the child list. 
            @param oldChild The node being replaced in the list. 
            @return The node replaced if found, null otherwise.
        </member>
        <member name="F:MathML.Rendering.LinearContainer.content">
            the child areas of a container
        </member>
        <member name="P:MathML.Rendering.LinearContainer.LeftEdge">
            find the smallest left side value of the child nodes
            if there are no child nodes, return 0
        </member>
        <member name="P:MathML.Rendering.LinearContainer.RightEdge">
            find the largest right edge in the content list.
            if the list is empty, return 0
        </member>
        <member name="F:MathML.Rendering.HorizontalArea.box">
            size of this area, calculated in ctor
        </member>
        <member name="M:MathML.Rendering.HorizontalArea.#ctor(MathML.Rendering.Area[])">
            create a new horizontal area, initialize the content
            child nodes list.
        </member>
        <member name="M:MathML.Rendering.HorizontalArea.#ctor(MathML.Rendering.Area[],MathML.Rendering.Area)">
            private ctor used for fit'ing
        </member>
        <member name="M:MathML.Rendering.HorizontalArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            render each child area with an updated rendering context
            to give each child a correct left side
        </member>
        <member name="M:MathML.Rendering.HorizontalArea.Origin(MathML.Rendering.AreaIdentifier)">
            get the width of all nodes up to the identified nodes, 
            plus the the origin of the identifed node.
            This is the relative distance from the identified node's origin
            to this node's origin.
        </member>
        <member name="M:MathML.Rendering.HorizontalArea.Fit(MathML.Rendering.BoundingBox)">
            fit the child areas into a box.
            Essentially, each child area is given an availible space which is proportional
            to its' strength with respect to the overall strength of the overall array. Areas
            that can not be re-sized in the width direction (have zero width strenght) simply
            get re-sized to thier natural width.
            
            NOTE: Derived classes must override this method (compound glyphs) because this returns
            a new HorzArea, not a derived type.
        </member>
        <member name="P:MathML.Rendering.HorizontalArea.BoundingBox">
            get a bounding box that encompases all child nodes
        </member>
        <member name="P:MathML.Rendering.HorizontalArea.LeftEdge">
            left edge only deals with first element
        </member>
        <member name="P:MathML.Rendering.HorizontalArea.RightEdge">
            right edge only cares about last element
        </member>
        <member name="P:MathML.Rendering.HorizontalArea.Strength">
            Sum the strengths of the child nodes in the width direction, and get the 
            max of the height and depth strengths.
        </member>
        <member name="T:MathML.Rendering.HorizontalCompoundGlyph">
            <summary>
            specialization of a horizontal area. This class is treated as a single
            glyph
            </summary>
        </member>
        <member name="M:MathML.Rendering.HorizontalCompoundGlyph.Fit(MathML.Rendering.BoundingBox)">
            a compound glyph is just a fixed collection of glyphs, it can not
            be resized, so just return this.
        </member>
        <member name="T:MathML.Rendering.HorizontalFillerArea">
            <summary>
            a filler area is used to specify a space area that will fit the avalible
            space in the containing area. A filler area can be thought of as a spring
            that pushes the areas next to it to opposite directions. A filler area is
            meant to be a temporary area to be substituted by a space area in the
            Fit method.
            </summary>
        </member>
        <member name="M:MathML.Rendering.HorizontalFillerArea.#ctor">
            <summary>
            nothing to initialize except base class
            </summary>
        </member>
        <member name="M:MathML.Rendering.HorizontalFillerArea.Fit(MathML.Rendering.BoundingBox)">
            <summary>
            fit this area to a bounding box
            create a new horizontal space area with the width of
            the given bounding box
            </summary>
        </member>
        <member name="P:MathML.Rendering.HorizontalFillerArea.BoundingBox">
            <summary>
            get a bounding box. 
            TODO figure out why we get these sizes
            </summary>
        </member>
        <member name="P:MathML.Rendering.HorizontalFillerArea.Strength">
            <summary>
            get the strength of this area
            Horizontal fillers can only stretch in the width direction, therefore, 
            only have re-size strength in the width direction
            </summary>
        </member>
        <member name="P:MathML.Rendering.HorizontalFillerArea.LeftEdge">
            <summary>
            get the left edge
            TODO figure out why we return these values
            </summary>
        </member>
        <member name="P:MathML.Rendering.HorizontalFillerArea.RightEdge">
            <summary>
            get the right edge
            TODO figure out why we return this value
            </summary>
        </member>
        <member name="T:MathML.Rendering.HorizontalSpaceArea">
            The space area represents a generic space area that renders
            nothing. Filler areas are replaced by space areas in the
            Fit process This class simply takes up horizontal space
        </member>
        <member name="M:MathML.Rendering.HorizontalSpaceArea.#ctor(System.Single)">
            create a new space area with the given width
        </member>
        <member name="P:MathML.Rendering.HorizontalSpaceArea.BoundingBox">
            get the bounding box of this area
            this area only takes up horizontal space, therefore
            it has no height or depth
        </member>
        <member name="P:MathML.Rendering.HorizontalSpaceArea.LeftEdge">
            TODO figure out why we return this value
        </member>
        <member name="P:MathML.Rendering.HorizontalSpaceArea.RightEdge">
            TODO figure out why we return this value
        </member>
        <member name="T:MathML.Rendering.IdArea">
            <summary>
            TODO document this class
            </summary>
        </member>
        <member name="T:MathML.Rendering.IgnoreArea">
            <summary>
            an area that performs no action, it has no size, no children, or rendering logic
            </summary>
        </member>
        <member name="P:MathML.Rendering.IgnoreArea.BoundingBox">
            <summary>
            create a bounding box with the minimum possible size
            </summary>
        </member>
        <member name="T:MathML.Rendering.InkArea">
            The ink area renders a solid box of ink (using the current color in the
            rendering context), whose extent is equal to the bounding box of the
            child area. The child area is not rendered
        </member>
        <member name="M:MathML.Rendering.InkArea.#ctor(MathML.Rendering.Area)">
            create an ink area.
            the ink area gets its' color from the color area which
            is rendered first.
        </member>
        <member name="M:MathML.Rendering.InkArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            render a filled rectangle with the current color that fills
            the area of the child node. Note, the context is given with
            coordinates at the origin of the bounding box, so we need to 
            calculate the extent of that rectangle here.
        </member>
        <member name="M:MathML.Rendering.InkArea.Clone">
            clone the object.
            Make a shallow copy of this object
        </member>
        <member name="T:MathML.Rendering.MathMLControlAction">
            <summary>
            Specifies the action that raised a MathMLControlEventArgs event.
            </summary>
        </member>
        <member name="F:MathML.Rendering.MathMLControlAction.ByKeyboard">
            <summary>
            The event was caused by a keystroke. 
            </summary>
        </member>
        <member name="F:MathML.Rendering.MathMLControlAction.ByMouse">
            <summary>
            The event was caused by a mouse
            </summary>
        </member>
        <member name="T:MathML.Rendering.MathMLControlEventArgs">
            <summary>
            provides data for all of the After events of the MathMLControl
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControlEventArgs.#ctor(MathML.MathMLElement,MathML.Rendering.MathMLControlAction)">
            <summary>
            creates a new MathMLControlEventArgs
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControlEventArgs.Action">
            <summary>
            the action that intiated this event
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControlEventArgs.Element">
            <summary>
            the element that was selected
            </summary>
        </member>
        <member name="T:MathML.Rendering.MathMLControlEventHandler">
            <summary>
            represents the method that will handle the After events of the MathMLControl
            </summary>
        </member>
        <member name="T:MathML.Rendering.MathMLControl">
            <summary>
            A control that displays and allows user updating of a mathml document
            Big new with this release is element selection is now working
            and enabled. Just double click on an element area with the mouse
            and it will become selected. An 'AfterSelect' event will be fired
            by the control.
            
            Experimental mathml editing is also included. This is disabled
            by default as it currently does not work very well, to enable
            editing, set the 'ReadOnly' property to false. Just select an
            element with the mouse to position the cursor. Move the cursor 
            with the arrow keys, and start typing to insert items. The 
            delete key will delete the item currently after the cursor. 
            
            NOTE, editing is VERY EXPERIMENTAL, it WILL CRASH!!! Do not 
            enable editing in any sort of released application.
            
            This control is work in progress, so  there are
            bound to be some problems. PLEASE let me know of ANY problems, 
            and let me known if you have ANY questions. send mail to
            andy@epsilon3.net
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.#ctor">
            <summary>
            create the control
            sets up the stule so this control is selectable
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.IsInputKey(System.Windows.Forms.Keys)">
            <summary>
            override the IsInputKeys so we get arrow key notifications
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.Save(System.String,System.Drawing.Imaging.ImageFormat)">
            <summary>
            save the current rendered image of a mathml document to a image file.
            </summary>
            <param name="filename">The file name to save to</param>
            <param name="format">the image file format</param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.Save(System.String)">
            <summary>
            save the mathml rendering to an image file. uses default
            image file format, see Image class
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.CopyToClipboard">
            <summary>
            copies the current mathml rendering to the clipboard in
            bitmap format.
            
            This name was ill-chosen, before selection and rendering were 
            implmemented, and this will be re-named in future versions.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.CopyToClipboard(System.Type)">
            <summary>
            copy the current mathml rendering to the clipboard in a specified
            format. The format can be either Bitmap or Metafile for an image 
            copy, or it can be String to copy the current selected element
            as a string.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.CopySelectedElementToClipboard">
            <summary>
            copy the currently selected mathml element to the clipboard
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.Draw(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            draw the current mathml element (if we have one) to the given
            device context clipping to the given size
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnPaintBackground(System.Windows.Forms.PaintEventArgs)">
            <summary>
            prevent clearing of the background, causes flicker
            </summary>
            <param name="pevent"></param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            clear the given graphics object and draw the mathml rendering into it
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.GetElementAtPoint(System.Drawing.Point)">
            <summary>
            Find the MathMLElement from which the item at the given point was
            created.
            </summary>
            <param name="point">Screen coordinated of the point</param>
            <returns>A MathMLElement if it under the point, null if no item is under the point</returns>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnMouseDown(System.Windows.Forms.MouseEventArgs)">
            <summary>
            handle a mouse click event
            if we have a single click, move the cursor to the mouse location if we are in edit mode.
            In a double click, select the element under the mouse click.
            </summary>
            <param name="e">mouse event args</param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)">
            <summary>
            handle a key press
            If we are in edit mode, insert a char at the proper location.
            </summary>
            <param name="e">KeyPressEventArgs</param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnKeyDown(System.Windows.Forms.KeyEventArgs)">
            <summary>
            handle a key down event (control keys)
            if we are in edit mode, take the appropriate action
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.Insert(System.Object)">
            <summary>
            insert an object at the current edit location.
            The object can currently be of type character, string or MathMLElement.
            </summary>
            <param name="obj"></param>
            <returns>true if the insert was successfull, false otherwise</returns>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.DeleteCurrentElement">
            <summary>
            delete the element at the current insert (caret) location
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.GetImage(System.Type)">
            <summary>
            Draw the current mathml equation to an image object.
            This method replaces the Metafile property.
            </summary>
            <param name="type">The type of image to return, currently this can be
            either Bitmap or Metafile</param>
            <returns>A new image, null if an invalid type is given or there is no current element</returns>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnMouseMove(System.Windows.Forms.MouseEventArgs)">
            <summary>
            override the mouse move event to determine which element the mouse is entering
            or leaving
            </summary>
            <param name="e">event args</param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnNodeChanged(System.Object,System.Xml.XmlNodeChangedEventArgs)">
            <summary>
            called whenever a node is changed in the currently loaded mathml document
            </summary>
            <param name="sender">the sender of the event</param>
            <param name="e">event args</param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnNodeRemoving(System.Object,System.Xml.XmlNodeChangedEventArgs)">
            <summary>
            called when a node is being removed.
            This sets up the next node to be selected after the current node is removed.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnNodeRemoved(System.Object,System.Xml.XmlNodeChangedEventArgs)">
            <summary>
            called whenever a node is removed from currently loaded mathml document.
            </summary>
            <param name="sender">the sender of the event</param>
            <param name="e">arguments for event</param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnNodeInserted(System.Object,System.Xml.XmlNodeChangedEventArgs)">
            <summary>
            called whenever a node is being inserted
            causes a re-layout 
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnElementSelected(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Raises the ElementSelected event.
            called whenever a user selects a element. Currently a user can only select an
            element with a double click.
            the base implementation raises the AfterSelect event.
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding OnElementSelected in a derived class, be sure to call 
            the base class's OnElementSelected method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnElementMouseEnter(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Called when the mouse pointer enters a mathml element region.
            Raises the ElementMouseEnter event. 
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding OnElementMouseEnter in a derived class, be sure to call 
            the base class's OnElementMouseEnter method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnElementMouseLeave(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Called when the mouse pointer leaves a mathml element region.
            Raises the ElementMouseLeave event. 
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding ElementMouseLeave in a derived class, be sure to call 
            the base class's ElementMouseLeave method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnElementMouseHover(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Called when the mouse pointer hovers over a mathml element region.
            Raises the ElementMouseHover event. 
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding ElementMouseHover in a derived class, be sure to call 
            the base class's ElementMouseHover method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnElementMouseClick(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Called when the mouse pointer hovers over a mathml element region.
            Raises the ElementMouseHover event. 
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding ElementMouseHover in a derived class, be sure to call 
            the base class's ElementMouseHover method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnActionElementMouseLeave(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Called when the mouse pointer leaves a mathml action element region.
            If an action element has an action type of "highlight", this will turn
            highlighting off. If the action element has an action type of "tooltip", the
            tooltip will be de-activated.
            Raises the ActionElementMouseLeave event. 
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding OnActionElementMouseLeave in a derived class, be sure to call 
            the base class's OnActionElementMouseLeave method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnActionElementMouseEnter(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Called when the mouse pointer enters a mathml action element region.
            If the action element has an action type of "highlight", this will turn
            highlighting on. If the action element has an action type of "tooltip" and
            there is a second child element that contains text, the text will be
            displayed as a tool tip over the action element. 
            Raises the ActionElementMouseEnter event. 
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding OnActionElementMouseEnter in a derived class, be sure to call 
            the base class's OnActionElementMouseEnter method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.OnActionElementMouseClick(MathML.Rendering.MathMLControlEventArgs)">
            <summary>
            Called when there is a single click in side a region bordered by an action element.
            If an action elememnt has an action type of "toggle", this will toggle the element.
            Raises the ActionElementMouseClick event. 
            </summary>
            <param name="args">event arguments</param>
            <remarks>
            Notes to Inheritors:  When overriding OnActionElementMouseClick in a derived class, be sure to call 
            the base class's OnActionElementMouseClick method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.Refresh">
            <summary>
            Override the Refresh method to set the new scroll min size for the current
            mathml element and also set the cached area size.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.CopyMetafileToClipboard(System.Drawing.Imaging.Metafile)">
            <summary>
            Due to a bug in the .net Clipboard object, we can not use it to
            past a metafile to the clipboard. We need to do it the old fasioned way.
            Metafile mf is set to a state that is not valid inside this function.
            </summary>
            <param name="mf"></param>
            <returns></returns>
        </member>
        <member name="M:MathML.Rendering.MathMLControl.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Need to override the winproc so the control is fully invalited at each
            message that can cause scroll event.
            </summary>
            <param name="m"></param>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ElementSelected">
            <summary>
            Occurs after a element is selected.
            </summary>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ElementMouseEnter">
            <summary>
            Occurs when the mouse pointer hovers enters a mathml element region.
            </summary>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ElementMouseHover">
            <summary>
            Occurs when the mouse pointer hovers over a mathml element region.
            </summary>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ElementMouseLeave">
            <summary>
            Occurs when the mouse pointer hovers leaves a mathml element region.
            </summary>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ElementMouseClick">
            <summary>
            Occurs when the mouse pointer single clicks on an element
            </summary>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ActionElementMouseClick">
            <summary>
            Occurs when the mouse pointer single clicks on a mathml action element.
            </summary>
            <remarks>
            The Element property of MathMLControlEventArgs will be a MathMLActionElement type.
            </remarks>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ActionElementMouseEnter">
            <summary>
            Occurs when the mouse pointer enters a mathml action element 
            </summary>
            <remarks>
            The Element property of MathMLControlEventArgs will be a MathMLActionElement type.
            </remarks>
        </member>
        <member name="E:MathML.Rendering.MathMLControl.ActionElementMouseLeave">
            <summary>
            Occurs when the mouse pointer leaves a mathml action element
            </summary>
            <remarks>
            The Element property of MathMLControlEventArgs will be a MathMLActionElement type.
            </remarks>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.ReadOnly">
            <summary>
            Can this control edit a mathml document. If true, the user can edit a document
            via keyboard input, false, the document is treated as readonly and keyboard edit
            input is ignored.
            
            Editing is very experimential, and will probably crash, use at your own risk.
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.VerticalShift">
            <summary>
            a old lame way to shift the mathml rendering
            control now auto-scrolls.
            <see cref="!:AutoScroll"/>
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.HorizontalShift">
            <summary>
            a old lame way to shift the mathml rendering
            control now auto-scrolls.
            <see cref="!:AutoScroll"/>
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.MathFontSizeInPoints">
            <summary>
            get or set the current base font size in points. This is the point size
            of a standard base level text.
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.MathElement">
            <summary>
            get or set the current mathml document
            Note, this documeht is live, all external updates to the document will be reflected in the 
            control.
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.SelectedElement">
            <summary>
            The currently selected element. Null if no element is selected. 
            Can be set a valid element to select an element or null if no 
            element is to be selected.
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.InputLocation">
            <summary>
            The input location or caret location. The caret is position directly
            before this element. Can be set to null to hide the caret.
            
            Currently not implemented
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.SelectionColor">
            <summary>
            get or sets the background color of a selected element.
            a set causes an automatic redraw.
            </summary>
        </member>
        <member name="P:MathML.Rendering.MathMLControl.Metafile">
            <summary>
            Draw the current mathml document to a metafile and return it.
            This method is obsolete, has been replaced by GetImage(ImageFormat.Wmf).
            </summary>
        </member>
        <member name="T:MathML.Rendering.MathMLElementFinder">
            <summary>
            Summary description for MathMLElementFinder.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLElementFinder.GetNextSelection(MathML.MathMLElement,System.Int32)">
            <summary>
            get an mathml element with the given relationship to the current element
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLElementFinder.GetPrevSelection(MathML.MathMLElement,System.Int32)">
            <summary>
            get an mathml element with the given relationship to the current element
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLElementFinder.HasMathChildNodes(MathML.MathMLElement)">
            <summary>
            does the node have any child nodes that are mathml elements?
            </summary>
        </member>
        <member name="T:MathML.Rendering.MathMLFormatter">
            <summary>
            walks the mathml dom tree, and creates an area tree
            
            The general concept here is that the mathml dom is a tree
            structure, and the most natural way of walking a tree is
            through recursion, where we use the stack space of the various
            functions to hold some state. We have a similar process here, 
            where each function calls other functions recursivly, but as
            the visitor interface is allready defined, we can not pass
            paramerters via function calls. Instead, we have pointers
            to the current area and context being formated. Each function
            call that modifies them needs to save them locally, set the pointer
            to an updated context or area, and then recursivly call
            one of the other methods. As the stack unwinds, the functions
            are returned to, and they need to restore the current pointers.
            </summary>
            <remarks>
            Note about stretchy-ness:
            Stretchyness has a definite scope, an operator can be stretched to 
            fit the imediate encompasing row. A row can not contain another
            row and expect the contained row's operators to stretch to fit the 
            outer row. So, stretchyness is scoped to the current row. A table
            cell element can contain operators and these operators will be expected
            to stretch to fit the cell. A cell's dimensions is only known after the
            table is formatted, so creating areas for a table is very similar to
            creating child areas for a row. First all the elemnents are created
            in a non-streatched state, then the column and row widths and heights
            are calculated, then the first level child operators will be asked to 
            stretch to fit the cell.
            
            Vertical Stretching Rules:
            * If a stretchy operator is a direct sub-expression of an mrow element, 
              or is the sole direct sub-expression of an mtd element in some row of a table, 
              then it should stretch to cover the height and depth (above and below the axis) 
              of the non-stretchy direct sub-expressions in the mrow element or table row, 
              unless stretching is constrained by minsize or maxsize attributes.
            * In the case of an embellished stretchy operator, the preceding rule applies 
              to the stretchy operator at its core.
            * If symmetric="true", then the maximum of the height and depth is used to 
              determine the size, before application of the minsize or maxsize attributes.
            * The preceding rules also apply in situations where the mrow element is inferred.
            
            Horizontal Stretching Rules:
            * If a stretchy operator, or an embellished stretchy operator, is a direct 
              sub-expression of an munder, mover, or munderover element, or if it is the sole 
              direct sub-expression of an mtd element in some column of a table (see mtable), 
              then it, or the mo element at its core, should stretch to cover the width of
              the other direct sub-expressions in the given element (or in the same table column), 
              given the constraints	mentioned above.
            * If a stretchy operator is a direct sub-expression of an munder, mover, 
              or munderover element, or if it is the sole direct sub-expression of an mtd element 
              in some column of a table, then it should stretch to cover the width of the other 
              direct sub-expressions in the given element (or in the same table column),
              given the constraints mentioned above.
            * In the case of an embellished stretchy operator, the preceding rule applies to the 
              stretchy operator at its core.
            </remarks>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Format(MathML.MathMLMathElement,MathML.Rendering.FormattingContext)">
            <summary>
            create an an area tree from root mathml element
            adds a default font area to the root of the area 
            tree to set the default font.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLApplyElement,System.Object)">
            <summary>
            format an apply element
            </summary>
            <param name="e"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLMathElement,System.Object)">
            <summary>
            process the root mathml math element.
            a "math" element may accoring to the spec contain arbitrary 
            many child elements, so we create an implicit mrow out of
            all the child elements.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLActionElement,System.Object)">
            <summary>
            action element is faked out for now.
            currently we only grab the last child (activated state)
            and render it
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLFencedElement,System.Object)">
            <summary>
            format a fenced element. We assume that the fenced opening and closing
            items are stretchy items. We pretty much just format this like a container, 
            except we put the separators in place
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.FenceArea(MathML.Rendering.Area,System.Int32,System.Char,System.Char)">
            <summary>
            fence an area with a set of glyphs. The glyphs will stretch if they can
            to fit the vertical extent of the area.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLStyleElement,System.Object)">
            <summary>
            format a style element.
            re-set the formatting context to the values of the style
            element, and format the sub-tree
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLTableCellElement,System.Object)">
            <summary>
            this is really just a presentation container, the formatting context
            is allready updated with any special formatting needs here.
            
            table cells area not cached, if a table is required to be re-flowed, 
            the cells allways have to be re-layed out
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLCiElement,System.Object)">
            <summary>
            format a content identifier
            </summary>
            <param name="e"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLFractionElement,System.Object)">
            <summary>
            format a fraction
            </summary>		
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLGlyphElement,System.Object)">
            <summary>
            format a glyph.
            This is a terminal node, and has no context info
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLMultiScriptsElement,System.Object)">
            <summary>
            MathMLMultiScriptsElement not supported yet
            </summary>					
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLOperatorElement,System.Object)">
            <summary>
            Format an operator
            An operator should have only one child node, and it should be of
            type text or glyph. An operator 
            </summary>				
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLRadicalElement,System.Object)">
            <summary>
            format a radical element
            </summary>		
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLScriptElement,System.Object)">
            <summary>
            format a script element.
            </summary>		
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLPresentationToken,System.Object)">
            <summary>
             process a presentation token. This can be either a "mi", 
             "mn", or "mtext" element. These nodes can only have content
             of text or glyph nodes. This method process all of the child
             nodes of the element, verifies that they are indeed text nodes,
             or glyph elements, and depending on the content, creates either
             an array of glyphs in a horizontal array if the content is text
             nodes interspersed with glyph elements, or a string element
             if the content is a single text node 
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLSeparator,System.Object)">
            <summary>
            separators are ignored
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLPresentationContainer,System.Object)">
            <summary>
            process a mrow element.
            a mrow is a horizontal array of areas. many of these areas may need
            to be stretched, but we need to know what size to stretch them first, 
            so, we first create areas for all child nodes of this node that are 
            not stretchable glyphs, and calculate the extents of these areas 
            to find the min and max sizes, then we go back and create areas
            for the stretchable glyphs.
            </summary>
            <remarks>
            There is no way of knowing exactly how far to stretch glyphs in the
            width direction, so we calculate the avalilble width (total extent -
            width of non stretchy areas), and for each stretchy operator we create, 
            we subtract the new op's width from the avail width to get the new avail
            width for the next op. This does have the nasty side effect of stretching
            the first horizontally stretchy glyph to fill up all of the horizontal
            space.
            </remarks>		
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.FormatContainer(MathML.MathMLElement,MathML.Rendering.FormattingContext,System.Collections.ArrayList)">
            <summary>
            Format a row of elements. This can be either a presentation container or a mrow
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Visit(MathML.MathMLPlaceholderElement,System.Object)">
            <summary>
            format a placeholder element
            this creates the hollow dashed rectangle to indicate that a user
            can type in this area.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Colorize(MathML.MathMLPresentationToken,MathML.Rendering.Area)">
            <summary>
            set the foreground and background colors for an area derived from a 
            token area. This takes a formatted area tree, and if a color exists 
            for a token, this color is set to the area subtree, same for background
            color.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.CompleteArea(MathML.Rendering.FormattingContext,MathML.MathMLElement,MathML.Rendering.Area)">
            wrap the completed area with a MathMLWrapper area and set the
            elements area field to point to the newly completed area
        </member>
        <member name="M:MathML.Rendering.MathMLFormatter.Error(MathML.Rendering.FormattingContext,MathML.MathMLElement,System.String)">
            There was an error processing a node, create an error node.
            wrap the completed area with a MathMLWrapper area and set the
            elements area field to point to the newly completed area
        </member>
        <member name="T:MathML.Rendering.MathMLMeasurer">
            <summary>
            Summary description for MathMLMinimumSizeFinder.
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLMeasurer.#ctor(MathML.Rendering.MathMLFormatter)">
            <summary>
            this is essentially a stateless object, so nothing done here
            </summary>
        </member>
        <member name="M:MathML.Rendering.MathMLMeasurer.MeasureElement(MathML.Rendering.FormattingContext,MathML.MathMLElement)">
            <summary>
            Get the minimum formatted area size for the given element using the
            state of the given formatting context.
            
            Currently this just formats the element using the this as the formatter, 
            in the future, this will be optimized so that a visitor only calculates
            the min size instead of creating an entire sub tree of areas.
            </summary>
        </member>
        <member name="T:MathML.Rendering.MathMLTableSizer">
            calaulates sizes of table cells and spacing
            
            This class does not calculate offsets of cells, that is the job of the formatter.
            This class only calculates sizes of cells and spaces, that is suffcient information
            to lay out the cells in a grid.
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.equalColumns">
            equalColumns attr read from table
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.columns">
            collection of columns
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.cells">
            collection of cells, read from source table
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.cellSizes">
            collection of caculated cell sizes
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.tableShift">
            vertical shift of table, used in creating new TableArea
            this is not publically visible because the change in the bounding box
            size takes care of shifting the table
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.box">
            extent of table, when the table is sized, only the height is used.
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.solidLines">
            lines that form the vertical and horizontal lines
            of this table.
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.#ctor(MathML.Rendering.FormattingContext,MathML.Rendering.MathMLMeasurer,MathML.MathMLTableElement)">
            construct a new sizer. All calculations are done here.
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.CalculateTableWidth(MathML.Rendering.FormattingContext,MathML.MathMLTableElement,MathML.Rendering.MathMLTableSizer.Column[],System.Boolean,System.Int32)">
            calculates the minimum table width to satisfy all columns.
            This uses each column's Width property to determine the minimum
            required width to fit each column.
            
            pre-reqs: columns, column.Width and equalColumns have been set
            readonly function
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.CalculateColumnAvailSpace(MathML.Rendering.MathMLTableSizer.Column[],System.Single)">
            calculates the space available for auto / fit columns
            this is the availible table space after the fix and scale 
            widths have been subtracted from the given table width.
            readonly function
            @param tableWidth the current width of the table
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.DistributeSpace(MathML.Rendering.MathMLTableSizer.Column[],System.Single,System.Single,System.Int32,System.Boolean)">
            distrubute the calculated table width and column space
            to scaled, auto and fited columns
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.GetColumnWidths(MathML.MathMLTableElement,System.Int32)">
            a table element generaly has fewer length types than columns. This 
            method, using the spec of setting the last length from the table's
            'columnwidths' creates a array of lengths, one for each column, and
            sets each item to the last real value if the lenthts from the table
            is less than the number of columns
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.GetColumnLines(MathML.MathMLTableElement,System.Int32)">
            grab the column styles from the table. 
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.GetCellColumnCount(MathML.MathMLTableCellElement[][])">
            find the maximum column count from a collection of cells, 
            this is the row with the largest number of cells
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.GetCells(MathML.MathMLTableElement)">
            grab all the cells from a table and return them in a 2 dimensional array
            TODO optimize (cache) cell.attribute* calls
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.CreateColumns(MathML.Rendering.FormattingContext,MathML.Rendering.MathMLMeasurer,MathML.MathMLTableCellElement[][],MathML.Rendering.BoundingBox[][],System.Int32,MathML.Length[],MathML.Length[],MathML.Length)">
            calculate the required space to fit all the columns
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.GetRequiredWidth(MathML.Rendering.BoundingBox[])">
            find the largest minimum width in a collection of cells
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.CreateLines(MathML.Rendering.BoundingBox[][],MathML.MathMLTableCellElement[][],MathML.Rendering.MathMLTableSizer.Row[],MathML.Rendering.MathMLTableSizer.Column[],MathML.LineStyle[],MathML.LineStyle[],MathML.LineStyle)">
            initialize the dashed and solid lines
            pre-req verticalExtent is set
            
            The general idea behind this line layout algorighm is that from just 
            a grid of cells, with some null and other not, it is impossible to know
            where to place lines. If we have 2 adjacent cells, both null, we do
            not know to place a line between them as the left cell could be from
            a column spanning cell, and the right could be from a row spanning cell.
            
            So, we need to know spanning numbers. 
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.CalculateShiftAndSize(MathML.Rendering.FormattingContext,MathML.MathMLTableElement,MathML.Rendering.MathMLTableSizer.Row[],MathML.Rendering.MathMLTableSizer.Column[],MathML.Rendering.BoundingBox@,System.Single@)">
            initialize the shift and vertical extent vars
            The final shift is calcuated by the formatter because it requires information
            about the formatted size of the cell area.
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.GetTableShift(MathML.Rendering.FormattingContext,MathML.MathMLTableElement,MathML.Rendering.BoundingBox)">
            calculate a table shift
            the initially consists of entierly height, this is a value given to the 
            TableArea object to determine the vertical location of a table. 
            
            This value is also used to modify the bounding box that is returned from this 
            class that is used for the TableArea
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.DebugWriteColumnWidths(System.String)">
            print the widths of the given columns
        </member>
        <member name="P:MathML.Rendering.MathMLTableSizer.Cells">
            the cells that compose this table
        </member>
        <member name="P:MathML.Rendering.MathMLTableSizer.CellSizes">
            calculated sizes for each cell
        </member>
        <member name="P:MathML.Rendering.MathMLTableSizer.SolidLines">
            get the solid lines for the frame and cells
        </member>
        <member name="P:MathML.Rendering.MathMLTableSizer.DashedLines">
            get the dashed lines for the frame and cells
        </member>
        <member name="P:MathML.Rendering.MathMLTableSizer.CellShifts">
            get the location of each cell
        </member>
        <member name="P:MathML.Rendering.MathMLTableSizer.BoundingBox">
            the the bounds of this table after formatting
        </member>
        <member name="T:MathML.Rendering.MathMLTableSizer.ColumnType">
            The columnwidth attribute specifies how wide a column should be. The "auto" value means 
            that the column should be as wide as needed, which is the default. If an explicit value 
            is given, then the column is exactly that wide and the contents of that column are made 
            to fit in that width. The contents are linewrapped or clipped at the discretion of the 
            renderer. If "fit" is given as a value, the remaining page width after subtracting the 
            widths for columns specified as "auto" and/or specific widths is divided equally among 
            the "fit" columns and this value is used for the column width. If insufficient room 
            remains to hold the contents of the "fit" columns, renderers may linewrap or clip the 
            contents of the "fit" columns. When the columnwidth is specified as a percentage, the 
            value is relative to the width of the table. That is, a renderer should try to adjust the 
            width of the column so that it covers the specified percentage of the entire table width.
            
            Table width types:
            1: Scale is the set of columns that have a width define as x%. These
            will be a percentage of the total width.
            
            2: Fix: These have a pre-defined width
            
            3:
        </member>
        <member name="T:MathML.Rendering.MathMLTableSizer.Column">
            measurments for a column of table cells
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.Column.#ctor(MathML.Rendering.FormattingContext,MathML.Length,System.Single,System.Boolean)">
            construct a new TableColumn object
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.Column.ScaleWidth">
            if the width is a percentage, than this value is the pecent value / 100, so
            50% becomes .50
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.Column.FixedWidth">
            fixed width value type, only columns that are of type fixed width
            have this value set. If a column is not a fixed width type, this value
            is zero
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.Column.Width">
            current width of this column, initialially set to min width
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.Column.Spacing">
            is this a spacing or a normal column
        </member>
        <member name="F:MathML.Rendering.MathMLTableSizer.Column.MinimumWidth">
            minimum width the contained areas can be set to
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.Row.#ctor(MathML.MathMLTableCellElement[],MathML.Rendering.BoundingBox[])">
            construct a row that minimally encoloses a set of cell sizes
        </member>
        <member name="M:MathML.Rendering.MathMLTableSizer.Row.#ctor(System.Single)">
            construct a spacing row
        </member>
        <member name="T:MathML.Rendering.MathMLWrapperArea">
            <summary>
            Contains an area tree that is the result of formatting a MathMLElement, 
            this area type co-relates that area tree to the source MathMLElement.
            </summary>
        </member>
        <member name="T:MathML.Rendering.NonSelectionArea">
            An area type that effectivly hides the sub tree from cursor selection
            this is typically used for radical elements where we do not ever want the
            main radical glyph to ever be selected.
        </member>
        <member name="T:MathML.Rendering.OverlapArea">
            a container area where all child nodes share the same
            origin.
        </member>
        <member name="M:MathML.Rendering.OverlapArea.Fit(MathML.Rendering.BoundingBox)">
            fit all child area to the same box.
        </member>
        <member name="P:MathML.Rendering.OverlapArea.BoundingBox">
            get the bounding box that is the region of all the child
            areas overlapped
        </member>
        <member name="P:MathML.Rendering.OverlapArea.Strength">
            get the maximum strength of the child nodes in each direction.
        </member>
        <member name="T:MathML.Rendering.PredefinedSymbolType">
            <summary>
            type of predefined symbol
            </summary>
        </member>
        <member name="T:MathML.Rendering.PredefinedSymbolInfo">
            <summary>
            Addational info needed to render a MathMLPredefinedSymbol
            This strucrture defines the operator order (pre,in,postfix order)
            and the character(s) that make up a given 
            </summary>
        </member>
        <member name="M:MathML.Rendering.PredefinedSymbolInfo.Get(System.String)">
            <summary>
            lookup the predefined symbol from the symbol name
            </summary>
        </member>
        <member name="F:MathML.Rendering.PredefinedSymbolInfo.Type">
            <summary>
            how this predefined symbol should be rendered
            </summary>
        </member>
        <member name="F:MathML.Rendering.PredefinedSymbolInfo.Value">
            <summary>
            the character(s) that make up this symbol
            </summary>
        </member>
        <member name="F:MathML.Rendering.PredefinedSymbolInfo.Parens">
            <summary>
            place parens around an infix operator group.
            </summary>
        </member>
        <member name="F:MathML.Rendering.PredefinedSymbolInfo.ChildParens">
            <summary>
            Should child elements of this element surround themselves with parens.
            </summary>
        </member>
        <member name="T:MathML.Rendering.ShiftArea">
            shift the vertical position of the child branch
            by the shift amount. This aftects position and rendering
            
            Note, a positive value for the shift shifts the area up, a negative value shifts
            the area down
        </member>
        <member name="F:MathML.Rendering.ShiftArea.shift">
            the shift amount
        </member>
        <member name="M:MathML.Rendering.ShiftArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            render the child area branch shifted by the shift 
            amount
        </member>
        <member name="M:MathML.Rendering.ShiftArea.Clone">
            make a duplicate of this node
        </member>
        <member name="P:MathML.Rendering.ShiftArea.BoundingBox">
            get the child's box shifted by the shift amount
        </member>
        <member name="T:MathML.Rendering.GlyphMapper.SimpleGlyphAttributes">
            a mapping of a character to a glyph index in a font.
            
            A fast was is needed to retrieve cached fonts. The
            'correct' object oriented way would be to store a list
            of created glyph areas in the FontInstance. However, there
            will be far more glyphs than font instances created, so it
            is more effcient to store a list of glyphs of varying sizes 
            with this struct rather than a list of glyphs in each font 
            instance. The reason being, is that once this structure 
            is found (there will be a lot of them), we know the mapped
            glyph index, so we just search through usually no more than
            5 glyph instances, each with the same glyph index, just created
            with different font sizes, rather than searching through 
            many glyphs if they would be stored in the FontInstance.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.SimpleGlyphAttributes.Char">
            the character that this is a match for.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.SimpleGlyphAttributes.GlyphIndex">
            the index in the font of this character's glyph
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.SimpleGlyphAttributes.#ctor(System.Char,System.UInt16)">
            initially created with a null glyphs list because
            the majority of glyphs will never be used.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.SimpleGlyphAttributes.GetArea(MathML.Rendering.FontHandle)">
            get a glyph area for this glyph.
            this searches through the glyphs list to see
            if an area has allready been created for the mathing
            set of glyph index and font, if none exists, a new 
            glyph area is created and cached via a weak reference.
        </member>
        <member name="T:MathML.Rendering.Strength">
            store the attributes of a strength direction.
            this could just as easily been a BoundingBox, but making
            a separate class is a bit clearer to read
        </member>
        <member name="M:MathML.Rendering.Strength.#ctor(System.Int32,System.Int32,System.Int32)">
            create a Strength object
        </member>
        <member name="F:MathML.Rendering.Strength.Width">
            strength in the Width direction
        </member>
        <member name="F:MathML.Rendering.Strength.Height">
            strength in the Height direction
        </member>
        <member name="F:MathML.Rendering.Strength.Depth">
            strength in the Depth direction
        </member>
        <member name="T:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes">
            a set of glyph metrics for a collection of glyph indices.
            These are specific to a particular font instance.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.simpleGlyphs">
            set of attributes for the simple glyphs, this may be null
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.compoundGlyphs">
            set of attributes for the compound glyphs, this may be null.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.orientation">
            the orientation of this glyph
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.#ctor(System.IntPtr,MathML.Rendering.GlyphMapper.StretchyGlyphIndices@)">
            create a set of attributes.
            this calculates all of the glyph metrics from the graphic device.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.GetStretchyArea(MathML.Rendering.FontHandle,MathML.Rendering.BoundingBox,System.Single@)">
            try to get a stretchy glyph 3 different ways, first try to find a 
            simple glyph that is just larger than the desired size. If we can
            not find a simple glyph, we try to fit together a compound glyph
            by repeating the filler area. If that fails, the last resort is 
            to just get the largest simple glyph.
            
            once a glyph is found, it is centered in the desiredSize region.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.GetLineThickness">
            calulated the line thickness for an glyph for which we have a repated filler 
            section. The line thickness is the width of the filler section.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.GetSimpleArea(MathML.Rendering.FontHandle,MathML.Rendering.BoundingBox)">
            search through all of the simple glyphs for this character, and 
            return the first one that is just larger that the requested 
            size. return null if no mathching glyph is found
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.GetFillerCount(System.Single)">
            calculate the number of filler areas needed to fill
            a region. There may be cases where the avail space is zero, 
            such as if the 2 fixed pieces of a stretchy glyph are larger
            than the area to be fitted. If avail space is negative, 0 
            filler count is returned.
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.StretchyGlyphAttributes.ShiftArea(MathML.Rendering.Area,MathML.Rendering.BoundingBox)">
            center the area in the desired size
        </member>
        <member name="T:MathML.Rendering.GlyphMapper.StretchyGlyphIndices">
            a 'stretchy glyph' is composed of several parts.
            a font can have one or more glyphs of varying sizes for
            a particular character. These are the 'simple glyphs'. For 
            example, the cmex10 font has 4 different sizes of the ')' 
            character. a font can aslo have a set of glyphs that make 
            a 'compound glyph'. These are glyphs that are pieced
            together from serveral smaller glyphs, usually, the center 
            glyph is repeated to achive tall skinny stretched glyphs.
            
            This struct hold the indeces in the font for the various
            glyphs that map to a character.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphIndices.Bottom">
            indices of the compound glyphs, and what they mean
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphIndices.Char">
            the character that these indices are for
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphIndices.SimpleIndices">
            set of simple glyphs, of varying sizes, stored
            from smallest to largest.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphIndices.CompoundIndices">
            indices for the compound glyphs.
            formated as such:
            index 0 is the bottom glyph, -1 if none exists.
            index 1 is the repeated glyph, this needs to be here.
            index 2 is the middle glyph if one exists, -1 otherwise.
            index 3 is the top glyph if one exists, -1 otherwise.
        </member>
        <member name="F:MathML.Rendering.GlyphMapper.StretchyGlyphIndices.Orientation">
            stretch vertially or horizontally
        </member>
        <member name="M:MathML.Rendering.GlyphMapper.StretchyGlyphIndices.#ctor(System.Xml.XmlElement)">
            load this set from an xml element.
        </member>
        <member name="T:MathML.Rendering.StringArea">
            A string area would behave like a horizontal array of glyps
            This is an optimization of an array of glyphs, as a string is 
            always rendered with the same font, color, and other text attributes.
            This saves having to switch to font out for each character.
            A string area is an imutable terminal node, no change in the
            rendering device will afect the size (although a change in the
            rendering device can change the final color, but never the
            size), this is why a string area keeps a reference to its' own
            font. Selecting and de-selecting in the rendering device is a 
            fairly cheap operation, it because this node is imutable, it
            allows some very good performance optimizations, like caching
            the bounding box of the string, since calculating the string 
            bounding box is VERY expensive. 
            
            TODO handle left and right, but these may be ignored in the future.
        </member>
        <member name="F:MathML.Rendering.StringArea.content">
            the actual string that will be rendered
        </member>
        <member name="F:MathML.Rendering.StringArea.font">
            keep track of the font
        </member>
        <member name="F:MathML.Rendering.StringArea.box">
            keep track of the bouning box, calculated in the ctor
        </member>
        <member name="F:MathML.Rendering.StringArea.leftEdge">
            the left and right edges
        </member>
        <member name="M:MathML.Rendering.StringArea.#ctor(MathML.Rendering.FormattingContext,System.String)">
            create a string area
        </member>
        <member name="M:MathML.Rendering.StringArea.Clone">
            String areas ares are read only, so just return this object
        </member>
        <member name="T:MathML.Rendering.TableArea">
            <summary>
            Summary description for TableArea.
            </summary>
        </member>
        <member name="M:MathML.Rendering.TableArea.#ctor(MathML.MathMLTableElement,MathML.Rendering.Area[],MathML.Rendering.BoundingBox,System.Drawing.PointF[],System.Drawing.PointF[],MathML.Rendering.Area)">
            private ctor used for fit operation
        </member>
        <member name="M:MathML.Rendering.TableArea.Fit(MathML.Rendering.BoundingBox)">
            fit all child area to thier own bounding box.
        </member>
        <member name="T:MathML.Rendering.TableCellArea">
            TODO better documentation
        </member>
        <member name="M:MathML.Rendering.TableCellArea.#ctor(MathML.MathMLElement,MathML.Rendering.Area,MathML.Rendering.BoundingBox,System.Drawing.PointF,System.Drawing.PointF)">
            create a box area.
        </member>
        <member name="M:MathML.Rendering.TableCellArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            x and y are the upper left corner of the parent table
        </member>
        <member name="M:MathML.Rendering.TableCellArea.Clone">
            clone the box area
        </member>
        <member name="P:MathML.Rendering.TableCellArea.BoundingBox">
            get the bounding box.
            as a BoxArea is fit to a certain size, it returns
            that size here.
        </member>
        <member name="P:MathML.Rendering.TableCellArea.Strength">
            A table cell is not stretchable after it is formatted, so return
            0 in all directions
        </member>
        <member name="T:MathML.Rendering.Utility">
            general utility functions
        </member>
        <member name="M:MathML.Rendering.Utility.ParseShortArray(System.String)">
            parse a string stored in the config xml that encodes a number array
        </member>
        <member name="F:MathML.Rendering.Utility.CultureInfo">
            <summary>
            make a culture info because all the config files are encoded
            with US english format numbers
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MathML.Rendering.VerticalArea" -->
        <member name="F:MathML.Rendering.VerticalArea.baseline">
            index of the baseline element
        </member>
        <member name="F:MathML.Rendering.VerticalArea.box">
            the bounding box of this area, calcuated in the ctor
        </member>
        <member name="M:MathML.Rendering.VerticalArea.#ctor(MathML.Rendering.Area[],System.Int32)">
            default public ctor
        </member>
        <member name="M:MathML.Rendering.VerticalArea.#ctor(MathML.Rendering.Area[],System.Int32,MathML.Rendering.Area)">
            private consturctor
        </member>
        <member name="M:MathML.Rendering.VerticalArea.Render(MathML.Rendering.GraphicDevice,System.Single,System.Single)">
            render all of the child areas.
        </member>
        <member name="M:MathML.Rendering.VerticalArea.Fit(MathML.Rendering.BoundingBox)">
            re-size all child nodes to the given width, and a height
            and depth proportional 
        </member>
        <member name="P:MathML.Rendering.VerticalArea.BoundingBox">
            calculate the extent of this area.
            The width is the max width of all child ares.
            The Height is the sum of all the area vertical extents
            above the baseline, and the depth is the sum of all the 
            vertical areas below the baseline.
        </member>
        <member name="P:MathML.Rendering.VerticalArea.Strength">
            get the strength
            the width strength is the max width strength of the child elements.
            the height strength is the sum of the height and depth strength
            of all nodes above the baseline.
            the depth strength is the sum of all the height and depth strength
            of all nodes bellow the baseline.
        </member>
        <member name="T:MathML.Rendering.VerticalCompoundGlyph">
            <summary>
            A specialization of the vertical area. This area only contains glyphs, and is 
            treaated as a single glyph
            </summary>
        </member>
        <member name="M:MathML.Rendering.VerticalCompoundGlyph.Fit(MathML.Rendering.BoundingBox)">
            a vertical compound area is treated as a single atomic object, just like 
            an individual glyph, so just return this
        </member>
        <member name="T:MathML.Rendering.VerticalFillerArea">
            a filler area is used to specify a space area that will fit the avalible
            space in the containing area. A filler area can be thought of as a spring
            that pushes the areas next to it to opposite directions. A filler area is
            meant to be a temporary area to be substituted by a space area in the
            Fit method.
        </member>
        <member name="M:MathML.Rendering.VerticalFillerArea.#ctor">
            just intiialize the base class
        </member>
        <member name="M:MathML.Rendering.VerticalFillerArea.Fit(MathML.Rendering.BoundingBox)">
            fit this area to a bounding box. This just
            creates a new vertical space area that is the height and depth
            of the bounding box
        </member>
        <member name="P:MathML.Rendering.VerticalFillerArea.BoundingBox">
            filler areas have no size
        </member>
        <member name="P:MathML.Rendering.VerticalFillerArea.LeftEdge">
            get the max value of Scaled.
            TODO figure out why
        </member>
        <member name="P:MathML.Rendering.VerticalFillerArea.RightEdge">
            get the min value for Scaled
            TODO figure out why
        </member>
        <member name="P:MathML.Rendering.VerticalFillerArea.Strength">
            vertical filler areas always have strength of 1 in
            the height and depth directions, and 0 in width
            TODO figure out why
        </member>
        <member name="T:MathML.Rendering.VerticalSpaceArea">
            The space area represents a generic space area that renders
            nothing. Filler areas are replaced by space areas in the
            Fit process This class simple takes up vertical space
        </member>
        <member name="F:MathML.Rendering.VerticalSpaceArea.depth">
            the depth of this space
        </member>
        <member name="F:MathML.Rendering.VerticalSpaceArea.height">
            the height of this space
        </member>
        <member name="M:MathML.Rendering.VerticalSpaceArea.#ctor(System.Single,System.Single)">
            create a new space area with the given dimensions
        </member>
        <member name="P:MathML.Rendering.VerticalSpaceArea.BoundingBox">
            get the space this area occupies
        </member>
        <member name="T:MathML.Rendering.Win32">
            direct access to win32 api methods
            
            This is a copy of the Win32.cs file from the font tester. 
            This class has way more methods than what is used or needed
            by the mathml renderer, and will be trimmed down to the bare
            essentials sometime in the future.
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_BEZIER">
            Windows 2000/XP: The function retrieves the curve data as a cubic 
            Bzier spline (not in quadratic spline format). 
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_BITMAP">
            The function retrieves the glyph bitmap. For information about memory 
            allocation, see the following Remarks section. 
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_GLYPH_INDEX">
            Windows 95/98/Me, Windows NT 4.0 and later: Indicates that the uChar 
            parameter is a TrueType Glyph Index rather than a character code. 
            See the ExtTextOut function for additional remarks on Glyph Indexing. 		
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_GRAY2_BITMAP">
            Windows 95/98/Me, Windows NT 4.0 and later: The function 
            retrieves a glyph bitmap that contains five levels of gray. 	
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_GRAY4_BITMAP">
            Windows 95/98/Me, Windows NT 4.0 and later: The function retrieves a 
            glyph bitmap that contains 17 levels of gray. 
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_GRAY8_BITMAP">
            Windows 95/98/Me, Windows NT 4.0 and later: The function retrieves a glyph 
            bitmap that contains 65 levels of gray. 	
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_METRICS">
            The function only retrieves the GLYPHMETRICS structure specified by lpgm. 
            The other buffers are ignored. This value affects the meaning of the function's 
            return value upon failure; see the Return Values section. 
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_NATIVE">
            The function retrieves the curve data points in the rasterizer's native 
            format and uses the font's design units.  
        </member>
        <member name="F:MathML.Rendering.Win32.GGO_UNHINTED">
            Windows 2000/XP: The function only returns unhinted outlines. This flag 
            only works in conjunction with GGO_BEZIER and GGO_NATIVE. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetCharABCWidths(System.IntPtr,System.UInt32,System.UInt32,MathML.Rendering.Win32.ABC[])">
            The GLYPHSET structure contains information about a range of 
            Unicode code points.
        </member>
        <member name="M:MathML.Rendering.Win32.CreateFontIndirect(MathML.Rendering.Win32.LOGFONT@)">
            The CreateFontIndirect function creates a logical font that has the 
            specified characteristics. The font can subsequently be selected as 
            the current font for any device context. 
        </member>
        <member name="M:MathML.Rendering.Win32.CreateSolidBrush(System.UInt32)">
            The CreateSolidBrush function creates a logical brush that has 
            the specified solid color. 
        </member>
        <member name="M:MathML.Rendering.Win32.RGB(System.Byte,System.Byte,System.Byte)">
            implementation of the standard win32 RGB macro
        </member>
        <member name="M:MathML.Rendering.Win32.RGB(System.Drawing.Color)">
            shortcut for color obj
        </member>
        <member name="M:MathML.Rendering.Win32.CreatePen(System.Int32,System.Int32,System.UInt32)">
            The CreatePen function creates a logical pen that has the specified style, 
            width, and color. The pen can subsequently be selected into a device context 
            and used to draw lines and curves. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetGlyphOutline(System.IntPtr,System.UInt32,System.UInt32,MathML.Rendering.Win32.GLYPHMETRICS@,System.UInt32,System.IntPtr,MathML.Rendering.Win32.MAT2@)">
            The GetGlyphOutline function retrieves the outline or bitmap for a 
            character in the TrueType font that is selected into the specified 
            device context. 
            
            Understanding what the documentation has to offer is only half the problem. 
            When the good doctor reviewed the documentation for GetGlyphOutline, his heart was 
            broken to find that the docs had, well  degenerated into an outline. So, here we 
            go with "Everything You Always Wanted to Know About GetGlyphOutline but Were 
            AfraidVery Afraidto Ask."
            To remedy this, the good doctor prescribes the following general overview of how 
            to use the function to get TrueType glyph outlines, and suggests a number of Microsoft 
            Knowledge Base articles that directly discuss the native buffer format.
            
            To retrieve the native TrueType outlines from GetGlyphOutline, you should call the 
            function twice using GGO_NATIVE for the uFormat parameter. For the first call to the 
            function, pass zero (0) and NULL for the buffer size and the pointer to the buffer, 
            respectively. The function then returns the required buffer size in bytes. Allocate the 
            buffer and call the function again with the appropriate parameters to retrieve the buffer 
            of outlines.
            
            Please note that, contrary to the current documentation, the MAT2 parameter modifies 
            the result of the function call. So, if you want an unmodified outline, make sure to 
            pass a true identity matrix to this parameter. An identity matrix is a MAT2 structure 
            with a value of one (1) in the eM11 and eM22 members and a value set to zero (0) for 
            all other members.
            
            Getting the outline is easy; decoding it is hard (and sometimes not unlike trying to 
            add some topical humor to a technical column). Here are some references and help that 
            can assist you in drawing an outline from the native data.
            
            You need to find and understand the TTPOLYGONHEADER, TTPOLYCURVE, and POINTFX structure 
            documentation to understand the native buffer format. The documentation for these 
            structures is accurate, but is not referenced by the GetGlyphOutline documentation. 
            It also describes the native outline data structures in rather terse terms. To get a 
            better description of these structures and the GGO_NATIVE buffer format, review the 
            following Knowledge Base article, which contains sample code to parse the native buffer 
            and to draw the Quadratic B-Spline curves that it contains: Q243285: HOWTO: Draw TrueType 
            Glyph Outlines.
            
            There is also a much older Knowledge Base article from the Windows 3.1 era, which also 
            describes the native buffer format: Q87115: HOWTO: GetGlyphOutline() Native Buffer Format.
            
            If, for some reason, your code runs on 3.x versions of Windows, or on platforms other 
            than Windows where Bezier drawing functions may not be available, you might also be 
            interested in Knowledge Base article: Q135058: How to Draw Cubic Bezier Curves in Windows 
            and Win32s.
            
            For a discussion of how Quadratic B-Spline curves are used in the contours of TrueType 
            outlines, see the TrueType Specification, revision 1.66. It's available on the MSDN CD, 
            or online at Microsoft Typography.
            
            If you are working with Unicode on Microsoft Windows 95 or Microsoft Windows 98, you should 
            review the following Knowledge Base articles, which discuss ways of using Unicode with the 
            GetGlyphOutline function: Q241020: HOWTO: Translate Unicode Character Codes to TrueType Glyph 
            Indices in Windows 95, and Q241358: PRB: The GetGlyphOutlineW Function Fails on Windows 95 
            and Windows 98.
            
            Also, the August 1999 issue of C/C++ Users Journal contains an introductory article on 
            TrueType Outlines titled "TrueType Font Secrets." It can give you a different and fresh 
            perspective on TrueType outlines.
            
            This information should get you started drawing the outlines, so the good doctor will now do 
            a dramatic finish by correcting the rest of the outline documentationor would that be 
            documentation outline?
            
            Anyway, the GGO_GLYPH_INDEX flag, contrary to the current documentation, has nothing to do 
            with ABC character spacing. If this flag is passed, it means that the UINT uChar parameter 
            is a 16-bit TrueType glyph index rather than a character code. Glyph indices can be obtained 
            with the GetCharacterPlacement function or through the techniques described in the 
            Knowledge Base article Q241020 just mentioned. The GGO_NATIVE format flag does not return 
            data in design units unless, as the documentation goes on to describe, the font is realized 
            with a size equal to the otmEMSquare of the OUTLINETEXTMETRIC structure. Also, the rasterizer 
            is capable of applying any transformation expressed in the MAT2 structure, not just rotation. 
            
            Finally, the GGO_GRAY8_BITMAP flag returns a bitmap whose byte values range from 0 to 64, 
            not 255 as the remarks section describes.
        </member>
        <member name="M:MathML.Rendering.Win32.GetTextExtentPoint32(System.IntPtr,System.String,System.Int32,MathML.Rendering.Win32.SIZE)">
            The GetTextExtentPoint32 function computes the width and height of 
            the specified string of text. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetTextMetrics(System.IntPtr,MathML.Rendering.Win32.TEXTMETRIC@)">
            The GetTextMetrics function fills the specified buffer with the metrics 
            for the currently selected font. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetDC(System.IntPtr)">
            The GetDC function retrieves a handle to a display device context (DC) 
            for the client area of a specified window or for the entire screen. 
            You can use the returned handle in subsequent GDI functions to draw 
            in the DC.
        </member>
        <member name="M:MathML.Rendering.Win32.ReleaseDC(System.IntPtr,System.IntPtr)">
            The ReleaseDC function releases a device context (DC), freeing it 
            for use by other applications. The effect of the ReleaseDC function 
            depends on the type of DC. It frees only common and window DCs. 
            It has no effect on class or private DCs. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetGlyphIndices(System.IntPtr,System.String,System.Int32,System.UInt16[],System.UInt32)">
            The GetGlyphIndices function translates a string into an array of 
            glyph indices. The function can be used to determine whether a 
            glyph exists in a font.
        </member>
        <member name="M:MathML.Rendering.Win32.GetLastError">
            The GetLastError function retrieves the calling thread's last-error code 
            value. The last-error code is maintained on a per-thread basis. Multiple 
            threads do not overwrite each other's last-error code.
        </member>
        <member name="M:MathML.Rendering.Win32.SelectObject(System.IntPtr,System.IntPtr)">
            The SelectObject function selects an object into the specified 
            device context (DC). The new object replaces the previous object 
            of the same type. 
        </member>
        <member name="M:MathML.Rendering.Win32.DeleteObject(System.IntPtr)">
            The DeleteObject function deletes a logical pen, brush, font, 
            bitmap, region, or palette, freeing all system resources associated 
            with the object. After the object is deleted, the specified handle 
            is no longer valid. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetCharABCWidthsI(System.IntPtr,System.UInt32,System.UInt32,System.UInt16[],MathML.Rendering.Win32.ABC[])">
            The GetCharABCWidthsI function retrieves the widths, in logical units, 
            of consecutive glyph indices in a specified range from the current 
            TrueType font. This function succeeds only with TrueType fonts. 
        </member>
        <member name="M:MathML.Rendering.Win32.DrawText(System.IntPtr,System.String,System.Int32,MathML.Rendering.Win32.RECT@,System.UInt32)">
            The DrawText function draws formatted text in the specified rectangle. 
            It formats the text according to the specified method (expanding tabs, 
            justifying characters, breaking lines, and so forth). 
            To specify additional formatting options, use the DrawTextEx function.
        </member>
        <member name="M:MathML.Rendering.Win32.ChooseFont(MathML.Rendering.Win32.CHOOSEFONT@)">
            The ChooseFont function creates a Font dialog box that enables 
            the user to choose attributes for a logical font. These 
            attributes include a typeface name, style (bold, italic, or regular), 
            point size, effects (underline, strikeout, and text color), and a 
            script (or character set). 
        </member>
        <member name="M:MathML.Rendering.Win32.GetTextFace(System.IntPtr,System.Int32,System.Char[])">
            The GetTextFace function retrieves the typeface name of the font 
            that is selected into the specified device context. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetCharABCWidthsFloat(System.IntPtr,System.UInt32,System.UInt32,MathML.Rendering.Win32.ABCFLOAT[])">
            The GetCharABCWidthsFloat function retrieves the widths, in logical units, 
            of consecutive characters in a specified range from the current font. 
        </member>
        <member name="M:MathML.Rendering.Win32.TextOut(System.IntPtr,System.Int32,System.Int32,System.String,System.Int32)">
            The TextOut function writes a character string at the specified 
            location, using the currently selected font, background color, 
            and text color. 
        </member>
        <member name="M:MathML.Rendering.Win32.TextOut(System.IntPtr,System.Int32,System.Int32,System.Char[],System.Int32)">
            Same as the previous TextOut, just with a minor change
            to help marshaling in certain cases
        </member>
        <member name="M:MathML.Rendering.Win32.SetTextAlign(System.IntPtr,System.UInt32)">
            The SetTextAlign function sets the text-alignment flags for the 
            specified device context. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetTextAlign(System.IntPtr)">
            The GetTextAlign function retrieves the text-alignment setting 
            for the specified device context. 
        </member>
        <member name="M:MathML.Rendering.Win32.LineTo(System.IntPtr,System.Int32,System.Int32)">
            The LineTo function draws a line from the current position up to, but 
            not including, the specified point. 
        </member>
        <member name="M:MathML.Rendering.Win32.MoveToEx(System.IntPtr,System.Int32,System.Int32,MathML.Rendering.Win32.POINT@)">
            The MoveToEx function updates the current position to the specified 
            point and optionally returns the previous position. 
        </member>
        <member name="M:MathML.Rendering.Win32.Rectangle(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            The Rectangle function draws a rectangle. The rectangle is outlined by 
            using the current pen and filled by using the current brush. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetDeviceCaps(System.IntPtr,System.Int32)">
            The GetDeviceCaps function retrieves device-specific information 
            for the specified device.
        </member>
        <member name="M:MathML.Rendering.Win32.GetTextExtentPoint32(System.IntPtr,System.String,System.Int32,MathML.Rendering.Win32.SIZE@)">
            The GetTextExtentPoint32 function computes the width and height of 
            the specified string of text. 
        </member>
        <member name="M:MathML.Rendering.Win32.SetBkMode(System.IntPtr,System.Int32)">
            he SetBkMode function sets the background mix mode of the specified 
            device context. The background mix mode is used with text, hatched brushes, 
            and pen styles that are not solid lines. 
        </member>
        <member name="M:MathML.Rendering.Win32.CreateCompatibleDC(System.IntPtr)">
            The CreateCompatibleDC function creates a memory device context (DC) compatible 
            with the specified device. 
        </member>
        <member name="M:MathML.Rendering.Win32.DeleteDC(System.IntPtr)">
            The DeleteDC function deletes the specified device context (DC).
        </member>
        <member name="M:MathML.Rendering.Win32.GetTextColor(System.IntPtr)">
            The GetTextColor function retrieves the current text color for the specified device context. 
        </member>
        <member name="M:MathML.Rendering.Win32.SetTextColor(System.IntPtr,System.UInt32)">
            The SetTextColor function sets the text color for the specified 
            device context to the specified color. 
        </member>
        <member name="M:MathML.Rendering.Win32.BitBlt(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.UInt32)">
            The BitBlt function performs a bit-block transfer of the color data corresponding 
            to a rectangle of pixels from the specified source device context into a destination 
            device context. 
        </member>
        <member name="M:MathML.Rendering.Win32.CreateCompatibleBitmap(System.IntPtr,System.Int32,System.Int32)">
            The CreateCompatibleBitmap function creates a bitmap compatible with the device that 
            is associated with the specified device context. 
        </member>
        <member name="M:MathML.Rendering.Win32.CreateCaret(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            The CreateCaret function creates a new shape for the system caret and assigns 
            ownership of the caret to the specified window. The caret shape can be a line, 
            a block, or a bitmap. 
        </member>
        <member name="M:MathML.Rendering.Win32.DestroyCaret">
            The DestroyCaret function destroys the caret's current shape, frees the caret 
            from the window, and removes the caret from the screen. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetCaretBlinkTime">
            The GetCaretBlinkTime function returns the time required to invert the caret's pixels. 
            The user can set this value. 
        </member>
        <member name="M:MathML.Rendering.Win32.GetSelection(MathML.Rendering.Win32.POINT@)">
            The GetSelection function copies the caret's position to the specified POINT structure. 
        </member>
        <member name="M:MathML.Rendering.Win32.HideCaret(System.IntPtr)">
            The HideCaret function removes the caret from the screen. Hiding a caret does not 
            destroy its current shape or invalidate the insertion point. 
        </member>
        <member name="M:MathML.Rendering.Win32.SetCaretBlinkTime(System.UInt32)">
            The SetCaretBlinkTime function sets the caret blink time to the specified 
            number of milliseconds. The blink time is the elapsed time, in milliseconds, 
            required to invert the caret's pixels. 
        </member>
        <member name="M:MathML.Rendering.Win32.SetCaretPos(System.Int32,System.Int32)">
            The SetSelection function moves the caret to the specified coordinates. 
            If the window that owns the caret was created with the CS_OWNDC class style, 
            then the specified coordinates are subject to the mapping mode of the device 
            context associated with that window. 
        </member>
        <member name="M:MathML.Rendering.Win32.ShowCaret(System.IntPtr)">
            The ShowCaret function makes the caret visible on the screen at the 
            caret's current position. When the caret becomes visible, it begins flashing automatically.
        </member>
        <member name="M:MathML.Rendering.Win32.GetStockObject(System.Int32)">
            The GetStockObject function retrieves a handle to one of the stock pens, 
            brushes, fonts, or palettes. 
        </member>
        <member name="M:MathML.Rendering.Win32.FillRect(System.IntPtr,MathML.Rendering.Win32.RECT@,System.IntPtr)">
            The FillRect function fills a rectangle by using the specified brush. 
            This function includes the left and top borders, but excludes the right 
            and bottom borders of the rectangle. 
        </member>
        <member name="M:MathML.Rendering.Win32.RoundRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            The RoundRect function draws a rectangle with rounded corners. The rectangle 
            is outlined by using the current pen and filled by using the current brush. 
        </member>
        <member name="M:MathML.Rendering.Win32.RoundRect(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            float version of the RoundRect function. This draws a rectangle that 
            fully encloses the given values.
            this probably should not go here, but does not really fit anywhere else.
        </member>
        <member name="F:MathML.Rendering.Win32.StockBlackPen">
            stock gid objects, read in static ctor
        </member>
        <member name="M:MathML.Rendering.Win32.OpenClipboard(System.IntPtr)">
            misc clipboard functions. These are needed because there is a bug in the 
            .net Clipboard object where the copying of a metafile does not
            work correctly.
        </member>
        <member name="M:MathML.Rendering.Win32.PatBlt(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
             The PatBlt function paints the specified rectangle using the brush that is currently 
             selected into the specified device context. The brush color and the surface color or 
             colors are combined by using the specified raster operation. 
            
        </member>
        <member name="M:MathML.Rendering.Win32.CreatePatternBrush(System.IntPtr)">
            The CreatePatternBrush function creates a logical brush with the specified bitmap pattern. 
            The bitmap can be a DIB section bitmap, which is created by the CreateDIBSection function, 
            or it can be a device-dependent bitmap.
        </member>
        <member name="T:MathML.Rendering.Win32.ABCFLOAT">
            The ABCFLOAT structure contains the A, B, and C widths 
            of a font character. 
        </member>
        <member name="T:MathML.Rendering.Win32.RECT">
            The RECT structure defines the coordinates of the upper-left 
            and lower-right corners of a rectangle. 
        </member>
        <member name="T:MathML.Rendering.Win32.POINT">
            The POINT structure defines the x- and y- coordinates of a point. 
        </member>
        <member name="T:MathML.Rendering.Win32.SIZE">
            The SIZE structure specifies the width and height of a rectangle. 
        </member>
        <member name="T:MathML.Rendering.Win32.GLYPHMETRICS">
            The GLYPHMETRICS structure contains information about the placement 
            and orientation of a glyph in a character cell. 
        </member>
        <member name="T:MathML.Rendering.Win32.FIXED">
            layed out correctly, fract is before val, even though
            the header file has them the other way. tested sep 22 2003, 
            and verified the order of the fields. If the fields are 
            reversed, GetGlyphOutline fails
        </member>
        <member name="T:MathML.Rendering.Win32.MAT2">
            The MAT2 structure contains the values for a transformation matrix 
            used by the GetGlyphOutline function. 
        </member>
        <member name="T:MathML.Rendering.Win32.TEXTMETRIC">
            The TEXTMETRIC structure contains basic information about a physical font. 
            All sizes are specified in logical units; that is, they depend on the 
            current mapping mode of the display context. 
        </member>
        <member name="T:MathML.Rendering.Win32.WCRANGE">
            The WCRANGE structure specifies a range of Unicode characters.
        </member>
        <!-- Badly formed XML comment ignored for member "T:MathML.Rendering.GraphicDevice" -->
        <member name="F:MathML.Rendering.GraphicDevice.measurmentContext">
            hold onto a context, only for measuring glyph metrics.
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.dc">
            The native device context (in the win32 version anyway, in a 
            future gtk version, this will be whatever the gtk equivilant
            to a device context is. This should be set before
            any calls are mede into the formating / layout trees.
            
            TODO this needs major cleanup, using this as 
            a static var is just asking for trouble.
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.currentColor">
            the current color (pen, text, brush)
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.currentPenColor">
            color of only current pen
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.currentPen">
            the current pen
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.solidPen">
            the current solid pen
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.dashedPen">
            the current dashed pen
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.dottedPen">
            current dotted pen
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.lineStyle">
            the current line style
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.solidBrushCache">
            static cach of solid brushes
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.Dpi(MathML.Rendering.FormattingContext)">
            get the dpi resolution of the current device
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.Ex(MathML.Rendering.FormattingContext)">
            the height of the character "x" in the current 
            font size
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.Axis(MathML.Rendering.FormattingContext)">
            the centerline of the current font, this is not 
            the baseline, but where the 2 lines cross in an 'x'
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.SetFont(System.IntPtr)">
            Sets the given font as the curent active font.
            @param font a native font resource returned from GetFont
            @return The previous font. This font MUST BE RESTORED when the new
            font is no longer used
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.RestoreFont(System.IntPtr)">
            restores a font previously returned from SetFont
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.DestroyFont(System.IntPtr)">
            destroy a native font resource
            note, this should only be called by the MathFont finalizer.
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.PointsToPixels(System.Single)">
            calculate how many pixels per point.
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.MMsToPixels(System.Single)">
            calculate how many pixels per mm.
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.CMsToPixels(System.Single)">
            calculate how many pixels per cm.
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.PicasToPixels(System.Single)">
            calculate how many pixels per pica.
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.InchesToPixels(System.Single)">
            calculate how many pixels per inch.
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.CreateFont(System.Int32,System.Boolean,System.Int32,System.String)">
            Create a native font resource. This MUST be explicitly deleted when it is 
            no longer needed by calling DestroyFont.
            
            @param emHeight the desired character height of the font, this is 
            the size above the baseline for a capital M, or the largest
            character height in the font		 
            @param italic create an italic font 
            @param weight the weight of the font
            @param fontName the face name of the font
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.MeasureGlyph(System.IntPtr,System.UInt16,MathML.Rendering.BoundingBox@,System.Single@,System.Single@)">
            get the glyph metrics of a glyph.
            in this case, the returned bounding box is the box that the 
            glyph metrics say fully encapsulate the glyph, including the 
            space on the left and right sides of the glyph. So, the width 
            of the box is the actual amout to advance the x position to
            draw the next glyph.
            
            note, this method is not extremly efficient, in the future, we
            may store glyph metrics with a glyph, or get a whole load of these
            in one block, and store them somewhere. The code needs to be 
            profiled, and we will see if this method is a bottle neck.
            
            @param font A handle to a native font.
            @param The char index (the actual character value)
            @param box The returned bounding box of the glyph
            @param left The distance from the origin the left colored edge of 
                        the glyph.
            @param right same as left.
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.DrawLines(System.Drawing.PointF[])">
            Draw a set of lines between each pair of points in the given array.
            The array must be a multiple of 2, as every 2 points starting at 0 
            form the end points of a line. 
            
            All lines will be single pixel wide
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.DrawLine(System.Drawing.PointF,System.Drawing.PointF)">
            Draw a set of lines between each pair of points in the given array.
            The array must be a multiple of 2, as every 2 points starting at 0 
            form the end points of a line. 
            
            All lines will be single pixel wide
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.SetupSolidPen">
            setup a solid pen using the current color.
            from mozilla
        </member>
        <member name="P:MathML.Rendering.GraphicDevice.Color">
            get / set the foreground of all output of this device. This will set 
            the text / line / fill color
        </member>
        <member name="P:MathML.Rendering.GraphicDevice.LineStyle">
            get / set the line style
        </member>
        <member name="T:MathML.Rendering.GraphicDevice.MeasurmentContext">
            wrap a win32 device context, and dispose of it when it is no
            longer needed.
        </member>
        <member name="F:MathML.Rendering.GraphicDevice.MeasurmentContext.Handle">
            the HDC
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.MeasurmentContext.#ctor">
            this is used only for measuremnt, so just make it like the 
            desktop DC
        </member>
        <member name="M:MathML.Rendering.GraphicDevice.MeasurmentContext.Finalize">
            done with the dc, so destroy it
        </member>
        <member name="T:MathML.Rendering.GraphicDevice.SolidBrushCache">
            Small cache of HBRUSH objects
            Note: the current assumption is that there is only one UI thread so
            we do not lock, and we do not use TLS
        </member>
    </members>
</doc>
